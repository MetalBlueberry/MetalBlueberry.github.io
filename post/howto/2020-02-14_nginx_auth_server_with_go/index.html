<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.59.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Ready to Go Auth server with Nginx&nbsp;&ndash;&nbsp;MetalBlueberry</title><link rel="stylesheet" href="/css/core.min.97dca4f10b4a76a5c62d6c5855e9eaab3b083ba20b6e4059f24dc20a8bb331c418ecdfd5449a29ef5333ebc2c64b286b.css" integrity="sha384-l9yk8QtKdqXGLWxYVenqqzsIO6ILbkBZ8k3CCouzMcQY7N/VRJop71Mz68LGSyhr"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ready to Go Auth server with Nginx"/>
<meta name="twitter:description" content="I got tired of seeing different implementations of authentication in different applications that tend to be insecure and hard to maintain. Usually, the best way to handle those situations is to delegate on someone with more experience like Google oauth2. But if you really need you own system&hellip; this approach should ease the work."/>

<meta property="og:title" content="Ready to Go Auth server with Nginx" />
<meta property="og:description" content="I got tired of seeing different implementations of authentication in different applications that tend to be insecure and hard to maintain. Usually, the best way to handle those situations is to delegate on someone with more experience like Google oauth2. But if you really need you own system&hellip; this approach should ease the work." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://metalblueberry.github.io/post/howto/2020-02-14_nginx_auth_server_with_go/" />
<meta property="article:published_time" content="2020-02-14T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-10T11:39:35+02:00" />

<meta name="author" content="MetalBlueberry">
<body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/android-chrome-512x512.png" alt /><span class="site name">MetalBlueberry</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/about">About</a><a class="nav item" href="/social">Follow me</a></nav></div></span></div><div class="site slogan"><span class="title">A passionate programmer</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Ready to Go Auth server with Nginx</h1><p class="article date">Friday, February 14, 2020<span class="lastmod"> • edited Friday, April 10, 2020</span></p></section><article class="article markdown-body"><p>I got tired of seeing different implementations of authentication in different applications that tend to be insecure and hard to maintain. Usually, the best way to handle those situations is to delegate on someone with more experience like <a href="https://developers.google.com/identity/protocols/OAuth2">Google oauth2</a>. But if you really need you own system&hellip; this approach should ease the work.</p>

<p>First thing, I will try to discourage you to actually do this to store your own passwords. Please, invest some time in watching this video from computerphile</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/8ZtInClXe1Q" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>Knowing this, I hope that you use this implementation being fully aware of what it means. Also keep in mind that I&rsquo;m not an expert and I will be glad to hear about improvements in what I&rsquo;m going to post here.</p>

<h1 id="sample-app">Sample App</h1>

<p>Let&rsquo;s create a simple docker-compose setup with a minimal application. I&rsquo;m going to include https configuration because it&rsquo;s not that hard. You can go <a href="https://www.humankode.com/ssl/create-a-selfsigned-certificate-for-nginx-in-5-minutes">here</a> to learn how to create your own self signed certificate.</p>

<p>File structure</p>

<pre><code class="language-txt">.
├── docker-compose.yaml
└── nginx
    ├── Dockerfile
    ├── localhost.conf
    ├── localhost.crt
    ├── localhost.key
    └── nginx.conf
</code></pre>

<p>docker-compose.yaml</p>

<pre><code class="language-yaml">version: &quot;2.2&quot;

services:
  nginx:
    image: nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/localhost.crt:/etc/ssl/certs/localhost.crt:ro
      - ./nginx/localhost.key:/etc/ssl/private/localhost.key:ro
    ports:
      - 80:80
      - 443:443

  whoami:
    image: jwilder/whoami
    ports:
      - 8000:8000
</code></pre>

<p>nginx.conf</p>

<pre><code class="language-nginx">http {
    server {
        listen 80;
        server_name localhost;

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name localhost;

        ssl_certificate /etc/ssl/certs/localhost.crt;
        ssl_certificate_key /etc/ssl/private/localhost.key;

        ssl_protocols TLSv1.2 TLSv1.1 ;


        location / {
            proxy_pass http://whoami:8000;
        }

    }
}
</code></pre>

<p>Et voilà! If you run docker-compose up, you will be able to get the output of whoami image using https from <a href="https://localhost">your browser</a>. BTW, whoami is the easiest application I can imagine. You can find more info <a href="https://hub.docker.com/r/jwilder/whoami/">here</a></p>

<h1 id="auth-server">Auth server</h1>

<p>Quote from the <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/">Nginx official documentation</a>. Please, read the docs ;)</p>

<blockquote>
<p><strong>NGINX and NGINX Plus</strong> can authenticate each request to your website with an <strong>external service</strong>. To perform authentication, NGINX makes an <strong>HTTP subrequest</strong> to an external server where the subrequest is verified. If the subrequest returns a 2xx response code, the access is allowed, if it returns 401 or 403, the access is denied. Such type of authentication allows implementing various authentication schemes, such as multifactor authentication, or allows implementing LDAP or OAuth authentication.</p>
</blockquote>

<p>Now that you understand how Nginx works, let&rsquo;s modify the configuration to protect our app with an auth server.</p>

<pre><code class="language-nginx">http {
    server {
        listen 80;
        server_name localhost;

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name localhost;

        ssl_certificate /etc/ssl/certs/localhost.crt;
        ssl_certificate_key /etc/ssl/private/localhost.key;

        ssl_protocols TLSv1.2 TLSv1.1 ;

        location = /auth {
            internal;
            proxy_pass http://auth-server:8080;
            proxy_pass_request_body off;
            proxy_set_header Content-Length &quot;&quot;;
            proxy_set_header X-Original-URI $request_uri;
        }

        location ~ ^/(login|logout) {
            proxy_pass http://auth-server:8080;
        }


        location / {
            proxy_pass http://whoami:8000;
            auth_request /auth;
            auth_request_set $auth_status $upstream_status;
        }
    }
}
</code></pre>

<h1 id="implementation">Implementation</h1>

<p>The process is really simple. You need the following three endpoint</p>

<ul>
<li><strong>login</strong>: POST that receives the user login information. typically from a html form.</li>
<li><strong>logout</strong>: POST empty that just removes the session.</li>
<li><strong>auth</strong>: GET to check if the user is logged in.</li>
</ul>

<p>Let&rsquo;s see how each handler looks like.</p>

<h2 id="loginposthandler">loginPOSTHandler</h2>

<ol>
<li>Extracts the values from the html form.</li>
<li>Tries to login the user with the given password.</li>
<li>If succeeds, It creates a JWT with 5 minutes expiration time.</li>
<li>Puts the user data inside.</li>
<li>Signs it.</li>
<li>Stores it in a cookie with the same expiration time.</li>
</ol>

<p>Here is the code.</p>

<pre><code class="language-go">func loginPOSTHandler(w http.ResponseWriter, r *http.Request) {
	username := r.FormValue(&quot;username&quot;)
	password := r.FormValue(&quot;password&quot;)

	user := loginUser(username, password)
	if user == nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	expirationTime := time.Now().Add(5 * time.Minute)
	claims := &amp;Claims{
		User: user,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &amp;http.Cookie{
		Name:     &quot;token&quot;,
		Path:     &quot;/&quot;,
		Value:    tokenString,
		Expires:  expirationTime,
		HttpOnly: true,
	})

	http.Redirect(w, r, basePath, http.StatusFound)
}
</code></pre>

<h2 id="logoutposthandler">logoutPOSTHandler</h2>

<p>This handler simply deletes the token cookies if exists.</p>

<pre><code class="language-go">func logoutPOSTHandler(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     &quot;token&quot;,
		Path:     &quot;/&quot;,
		MaxAge:   -1,
		HttpOnly: true,
	})

	http.Redirect(w, r, basePath, http.StatusFound)
}
</code></pre>

<h2 id="authhandler">authHandler</h2>

<p>The purpose of the authHandler is to validate the token generated by the loginPOSTHandler. Because this is something that will be performed in other places, I&rsquo;ve created the function getSession that given a requests, extracts the JWT claims or returns a nil claim if the token is not valid.</p>

<pre><code class="language-go">func authHandler(w http.ResponseWriter, r *http.Request) {
	claims, err := getSession(r)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if claims == nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	encoder := json.NewEncoder(w)
	encoder.Encode(claims.User)
}

func getSession(r *http.Request) (*Claims, error) {
	c, err := r.Cookie(&quot;token&quot;)
	switch {
	case err == http.ErrNoCookie:
		return nil, nil
	case err != nil:
		return nil, fmt.Errorf(&quot;Could not get token cookie. cause %w&quot;, err)
	}

	tokenString := c.Value
	claims := &amp;Claims{}

	tkn, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	switch {
	case err == jwt.ErrSignatureInvalid:
		return nil, nil
	case err != nil:
		return nil, fmt.Errorf(&quot;Could not parse jwt, cause %w&quot;, err)
	case !tkn.Valid:
		return nil, nil
	}

	return claims, nil
}

</code></pre>

<p>In a real world problem, you will provably implement some cool frontend that communicates with this service. For simplicity, I&rsquo;ve added a login GET handler that returns a the front end. This takes advantage of the go html/template package. See the source code to see the template code. I&rsquo;m only displaying the name for the logout template.</p>

<pre><code class="language-go">func loginGETHandler(w http.ResponseWriter, r *http.Request) {
	claims, err := getSession(r)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	pages := template.Must(template.ParseGlob(&quot;templates/*.tmpl&quot;))

	switch {
	case claims != nil:
		pages.ExecuteTemplate(w, &quot;logout.tmpl&quot;, claims)
	default:
		pages.ExecuteTemplate(w, &quot;login.tmpl&quot;, nil)
	}

}
</code></pre>

<div class="expand">
    <div class="expand-label" id="expand-label-1" style="cursor: pointer;">
        <span>
            
            
            Click here to see all code from main.go
            
        </span>
    </div>
    <div class="expand-content" id="expand-content-1" style="display: none;">
        <pre><code class="language-go">package main

import (
	&quot;encoding/json&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;html/template&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;time&quot;

	&quot;github.com/dgrijalva/jwt-go&quot;
	&quot;github.com/gorilla/mux&quot;
)

// Create the JWT key used to create the signature
var jwtKey = []byte(&quot;my_secret_key&quot;)

type UserData struct {
	Name        string `json:&quot;name,omitempty&quot;`
	Email       string `json:&quot;email,omitempty&quot;`
	AccessLevel int    `json:&quot;access_level,omitempty&quot;`
}

type Claims struct {
	User *UserData `json:&quot;user&quot;`
	jwt.StandardClaims
}

var basePath string

func main() {
	flag.StringVar(&amp;basePath, &quot;base-path&quot;, &quot;/&quot;, &quot;indicates the base path where the app is running&quot;)
	flag.Parse()

	r := mux.NewRouter().
		PathPrefix(basePath).
		Subrouter()
	r.Path(&quot;/auth&quot;).Methods(&quot;GET&quot;).HandlerFunc(authHandler)
	r.Path(&quot;/login&quot;).Methods(&quot;POST&quot;).HandlerFunc(loginPOSTHandler)
	r.Path(&quot;/logout&quot;).Methods(&quot;POST&quot;).HandlerFunc(logoutPOSTHandler)
	r.PathPrefix(&quot;/&quot;).Methods(&quot;GET&quot;).HandlerFunc(loginGETHandler)

	http.Handle(&quot;/&quot;, r)

	log.Println(&quot;ready&quot;)
	http.ListenAndServe(&quot;:8080&quot;, nil)
}

func loginPOSTHandler(w http.ResponseWriter, r *http.Request) {
	username := r.FormValue(&quot;username&quot;)
	password := r.FormValue(&quot;password&quot;)

	user := loginUser(username, password)
	if user == nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}

	expirationTime := time.Now().Add(5 * time.Minute)
	claims := &amp;Claims{
		User: user,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(jwtKey)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.SetCookie(w, &amp;http.Cookie{
		Name:     &quot;token&quot;,
		Path:     &quot;/&quot;,
		Value:    tokenString,
		Expires:  expirationTime,
		HttpOnly: true,
	})

	http.Redirect(w, r, basePath, http.StatusFound)
}

func loginGETHandler(w http.ResponseWriter, r *http.Request) {
	claims, err := getSession(r)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	pages := template.Must(template.ParseGlob(&quot;templates/*.tmpl&quot;))

	switch {
	case claims != nil:
		pages.ExecuteTemplate(w, &quot;logout.tmpl&quot;, claims)
	default:
		pages.ExecuteTemplate(w, &quot;login.tmpl&quot;, claims)
	}

}

func loginUser(username string, password string) *UserData {
	// TODO: Now any user can login, implement proper validation
	return &amp;UserData{
		Name: username,
	}
}

func logoutPOSTHandler(w http.ResponseWriter, r *http.Request) {
	http.SetCookie(w, &amp;http.Cookie{
		Name:     &quot;token&quot;,
		Path:     &quot;/&quot;,
		MaxAge:   -1,
		HttpOnly: true,
	})

	http.Redirect(w, r, basePath, http.StatusFound)
}

func authHandler(w http.ResponseWriter, r *http.Request) {
	claims, err := getSession(r)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	if claims == nil {
		w.WriteHeader(http.StatusUnauthorized)
		return
	}
	encoder := json.NewEncoder(w)
	encoder.Encode(claims.User)
}

func getSession(r *http.Request) (*Claims, error) {
	c, err := r.Cookie(&quot;token&quot;)
	switch {
	case err == http.ErrNoCookie:
		return nil, nil
	case err != nil:
		return nil, fmt.Errorf(&quot;Could not get token cookie. cause %w&quot;, err)
	}

	tokenString := c.Value
	claims := &amp;Claims{}

	tkn, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	switch {
	case err == jwt.ErrSignatureInvalid:
		return nil, nil
	case err != nil:
		return nil, fmt.Errorf(&quot;Could not parse jwt, cause %w&quot;, err)
	case !tkn.Valid:
		return nil, nil
	}

	return claims, nil
}
</code></pre>
    </div>
    <script>
        function collapse(e) {
            e = e || window.event;
            var target = e.target || e.srcElement,
                text = target.textContent || target.innerText;

            console.log("event received")
            console.log(target)

            target.classList.toggle("active");
            var content = this.nextElementSibling;
            console.log(content)
            console.log(content.style.display)
            if (content.style.display === "block") {
                content.style.display = "none";
                console.log(content.style.display)
            } else {
                content.style.display = "block";
            }
        }
        document.getElementById("expand-label-1").addEventListener("click", collapse);
    </script>
</div>

<h2 id="dockerize">Dockerize</h2>

<p>Like any other go project, let&rsquo;s use a simple multi-stage alpine image to get the minimal image size.</p>

<div class="admonition tip"><p class="admonition-title">tip</p>
  
<p>Copy first <strong>go.mod</strong> and <strong>go.sum</strong> and use <strong>go mod download</strong> to take advantage of Docker cache. This will save tons of time downloading dependencies.</p>


</div>

<pre><code class="language-Dockerfile">FROM golang:alpine AS build

WORKDIR /app

COPY go.mod .
COPY go.sum .
RUN go mod download

COPY *.go .
RUN go build

FROM alpine as run

WORKDIR /app

COPY templates templates
COPY --from=build /app/auth-server /app/

RUN chmod +x auth-server
ENTRYPOINT [ &quot;./auth-server&quot; ]
</code></pre>

<h2 id="final-docker-compose-yaml">Final docker-compose.yaml</h2>

<p>Now we just have to add the auth-server to the docker compose and provide the base path to ensure that it works properly.</p>

<pre><code class="language-yml">version: &quot;2.2&quot;

services:
  nginx:
    image: nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/localhost.crt:/etc/ssl/certs/localhost.crt:ro
      - ./nginx/localhost.key:/etc/ssl/private/localhost.key:ro
    ports:
      - 80:80
      - 443:443

  auth-server:
    build: auth-server
    command: [&quot;--base-path&quot;, &quot;/users/&quot;]

  whoami:
    image: jwilder/whoami
    ports:
      - 8000:8000
</code></pre>

<h1 id="run-it">Run it</h1>

<p>Start the service with docker compose and ensure to build the images again.</p>

<pre><code class="language-bash">docker-compose up --build
</code></pre>

<p>The workflow is:</p>

<ol>
<li>Navigate to <a href="https://localhost">https://localhost</a> to see that you are not allowed.</li>
<li>Navigate to <a href="https://localhost/users/">https://localhost/users/</a> to see the login form.</li>
<li>Login using the same name and password, IE: MetalBlueberry, MetalBluberry.</li>
<li>Go again to <a href="https://localhost">https://localhost</a> to see the whoami container.</li>
<li>Go to <a href="https://localhost">https://localhost</a> to see the logout form.</li>
<li>Click logout</li>
<li>Navigate to <a href="https://localhost">https://localhost</a> to see that you are not allowed.</li>
<li>Repeat until you get bored.</li>
</ol>

<h1 id="final-thoughts">Final thoughts</h1>

<p>How to protect the user/passwords or register new users is out of the scope, but I think <strong>you can easily extend this example</strong> to do whatever you want. Also, I would like to implement the &ldquo;next&rdquo; behaviour to properly redirect the users when they try to access to a protected page and instruct nginx to redirect users to login page if the page is protected. But again, this is out of the scope. Maybe in the near future.</p>

<p>The best thing about this approach is that you can protect anything without actually modifying it. If you have some legacy app or old code that do not implement user auth, this can easily add a new layer of protection without too much effort.</p>

<h1 id="conclusion">Conclusion</h1>

<p>I hope you&rsquo;ve enjoyed this post and <strong>I will appreciate any feedback</strong> in the comments bellow. I&rsquo;m fairly new to the world of nginx and I&rsquo;m discovering new things every day. For example, looks like there is a <a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-jwt-authentication/">JWT validation directive</a> for nginx that will effectively replace the auth endpoint implemented in this tutorial.</p>

<p>I&rsquo;m learning <a href="https://docs.traefik.io/">Traefik</a> at the same time and I&rsquo;m enjoying it a lot. I know that it offers less features than nginx, but looks like a really good idea if you are dealing with docker-compose or kubernetes. I&rsquo;m going to give it a try. From the docs, looks like it is compatible with the <a href="https://docs.traefik.io/middlewares/forwardauth/">auth request pattern</a></p>

<p>.</p>

<p>And as always, Thanks for watching.</p>

<p>.</p>

<p>Sorry, I&rsquo;ve been watching a lot of Michel Toys last week.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/GjgImsVqPfg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h1 id="references">References</h1>

<ul>
<li><a href="https://github.com/MetalBlueberry/AuthServer">Source Code</a></li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-subrequest-authentication/">nginx documentation - subrequest authentication</a></li>
<li><a href="https://www.humankode.com/ssl/create-a-selfsigned-certificate-for-nginx-in-5-minutes">nginx - Setup ssl for localhost</a></li>
<li><a href="https://github.com/pusher/oauth2_proxy">someone did something similar - oauth2_proxy</a></li>
<li><a href="https://www.w3schools.com/howto/howto_css_login_form.asp">html login form</a></li>
<li><a href="https://www.sohamkamani.com/blog/golang/2019-01-01-jwt-authentication/">Go JWT auth</a></li>
</ul></article><section class="article labels"><a class="category" href=/categories/howto/>howto</a><a class="tag" href=/tags/go/>go</a><a class="tag" href=/tags/docker/>docker</a></section></div><section class="article navigation"><p><a class="link" href="/post/howto/2020-03-11_use_git_to_track_git_versions/"><span class="li">&larr;</span>Use Git to track Git versions</a></p><p><a class="link" href="/post/blog/2020-01-11_boredom/"><span class="li">&rarr;</span>How to get bored</a></p></section><script src="https://utteranc.es/client.js" repo="MetalBlueberry/MetalBlueberry.github.io" issue-term="og:title"
    label="comment" theme="github-light" crossorigin="anonymous" async>
    </script></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Víctor Pérez Domingo</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150427130-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</body>

</html>