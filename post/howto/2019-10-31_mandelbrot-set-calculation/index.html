<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.59.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Mandelbrot Set Calculation&nbsp;&ndash;&nbsp;MetalBlueberry</title><link rel="stylesheet" href="/css/core.min.97dca4f10b4a76a5c62d6c5855e9eaab3b083ba20b6e4059f24dc20a8bb331c418ecdfd5449a29ef5333ebc2c64b286b.css" integrity="sha384-l9yk8QtKdqXGLWxYVenqqzsIO6ILbkBZ8k3CCouzMcQY7N/VRJop71Mz68LGSyhr"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mandelbrot Set Calculation"/>
<meta name="twitter:description" content="The Mandelbrot set is one of the most famous fractals and it is really simple to draw. Personally I enjoy a lot seeing how simple rules lead to complex patterns."/>

<meta property="og:title" content="Mandelbrot Set Calculation" />
<meta property="og:description" content="The Mandelbrot set is one of the most famous fractals and it is really simple to draw. Personally I enjoy a lot seeing how simple rules lead to complex patterns." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://metalblueberry.github.io/post/howto/2019-10-31_mandelbrot-set-calculation/" />
<meta property="article:published_time" content="2019-10-29T21:33:33+01:00" />
<meta property="article:modified_time" content="2020-04-10T11:39:35+02:00" />

<meta name="author" content="MetalBlueberry">
<body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/android-chrome-512x512.png" alt /><span class="site name">MetalBlueberry</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/about">About</a><a class="nav item" href="/social">Follow me</a></nav></div></span></div><div class="site slogan"><span class="title">A passionate programmer</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Mandelbrot Set Calculation</h1><p class="article date">Tuesday, October 29, 2019<span class="lastmod"> • edited Friday, April 10, 2020</span></p></section><article class="article markdown-body"><p>The Mandelbrot set is one of the most famous fractals and it is really simple to draw. Personally I enjoy a lot seeing how simple rules lead to complex patterns.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Mandel_zoom_00_mandelbrot_set.jpg/1024px-Mandel_zoom_00_mandelbrot_set.jpg" alt="Mandelbrot set image" /></p>

<blockquote>
<p>Mandelbrot set representation from <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">wikipedia</a>.</p>
</blockquote>

<h2 id="definition">Definition</h2>

<p>The Mandelbrot set is defined by a set of complex numbers for which the following function does not diverge when iterated from z = 0. This means that the value remains bounded in absolute value.</p>

<p>$$
f_c(z) = z^2 + c
$$</p>

<p>The following image displays the axes to see where the set is located in space. x axis is the real part and y axis is the imaginary part.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Mandelset_hires.png/322px-Mandelset_hires.png#center" alt="Mandelbrot set position" /></p>

<h2 id="keep-things-real">Keep things real</h2>

<p>Whit the previous image in mind, we can start playing with some sample numbers to understand how to generate the image. Let&rsquo;s pick a point outside the set <code>(1,0)</code> and perform the iterations with the previously defined function.</p>

<p>$$ z_0 := 0 $$
$$ c := 1 + 0i $$
$$ z_1 = f_c(z_0) = z^2 + c $$
$$ z_1 = f_c(0) = 0^2 + 1 + 0i = 1$$</p>

<p>After the fist iteration, $z_1 = 1$ and for the next iteration we just need to input the value to the function again.</p>

<p>$$ z_1 := 1 $$
$$ c := 1 + 0i $$
$$ z_2 = f_c(z_1) = z^2 + c $$
$$ z_2 = f_c(0) = 1^2 + 1 + 0i = 2$$</p>

<p>if we continue the iterations, we can see that the value keeps growing forever.</p>

<p>$$z_0 = 0$$
$$z_1 = 1$$
$$z_2 = 2$$
$$z_3 = 5$$
$$z_4 = 26$$</p>

<p>This means that the point doesn&rsquo;t belong to the set, as we know from the image. Let&rsquo;s pick a point that we know that belongs to the set. <code>(-1,0)</code>. if we are right, the iterations must keep within a bounded value.</p>

<p>$$ z_0 := 0 $$
$$ c := -1 + 0i $$
$$ z_1 = f_c(z_0) = z^2 + c $$
$$ z_1 = f_c(0) = 0^2 + -1 + 0i = -1$$
$$ z_2 = f_c(z_1) = z^2 + c $$
$$ z_2 = f_c(0) = (-1)^2 + -1 + 0i = 0$$</p>

<p>Wops&hellip; turns out that $z_2 = z_0$ and this means that we are stuck in a infinite loop. You can iterate as much as you want but values will be either -1 or 0 for ever.</p>

<h2 id="let-your-imagination-fly">Let your imagination fly</h2>

<p>Things get interesting the you add imaginary numbers to the previous equation so lets pick another point, but this time with imaginary values. <code>(-0.5, 0.5)</code></p>

<blockquote>
<p>Remember that $i^2 = -1$</p>
</blockquote>

<p>$$ z_0 := 0 $$
$$ c := -0.5 + 0.5i $$
$$ z_1 = f_c(0) = 0^2 + -0.5 + 0.5i = -0.5 + 0.5i $$
$$ z_2 = f_c(z_1) = (-0.5 + 0.5i)^2 + -0.5 + 0.5i = 0.25 - 2*0.25i - 0.25 - 0.5 + 0.5i $$
$$ z_2 = - 0.5 $$</p>

<p>Let&rsquo;s keep iterating and see what we get. Remember that we expect this point to belong to the set, so it should stay within a bounded value.</p>

<p>$$z_1=(-0.500000+0.500000i)$$</p>

<p>$$z_2=(-0.500000-0.000000i)$$</p>

<p>$$z_3=(-0.250000+0.500000i)$$</p>

<p>$$z_4=(-0.687500+0.250000i)$$</p>

<p>$$z_5=(-0.089844+0.156250i)$$</p>

<p>$$z_6=(-0.516342+0.471924i)$$</p>

<p>$$z_7=(-0.456103+0.012652i)$$</p>

<p>$$z_8=(-0.292130+0.488459i)$$</p>

<p>$$z_9=(-0.653252+0.214613i)$$</p>

<p>$$z_{10}=(-0.119320+0.219608i)$$</p>

<p>$$z_{20}=(-0.170860+0.314224i)$$</p>

<p>$$z_{30}=(-0.238482+0.376027i)$$</p>

<p>$$z_{40}=(-0.305512+0.399379i)$$</p>

<p>$$z_{50}=(-0.360070+0.401208i)$$</p>

<p>$$z_{60}=(-0.403868+0.390242i)$$</p>

<p>After 60 iterations, looks like the value stays within a bounded value but there is no guarantee that the value will remain here and the only way to know it is to keep iterating. That is why we need to define a maximum number of iterations to give up.</p>

<p>Last try with an imaginary number outside the set. <code>(0,1)</code></p>

<p>$$ z_2 = (1i)^2 + i = -1+i $$
$$ z_3 = (-1+i)^2 + i = 1 -2i -1 + i = -i $$
$$ z_4 = (-i)^2 + i = 1 + i = -1 + i $$
$$ z_5 = (-1+i)^2 + i = 1 -2i -1 + i = -i $$</p>

<p>What happen here? $z_2 = z_5$ and this means that we are stuck in a infinite loop therefore the point belongs to the set. This is just a special point that belongs to the set but if you move a minimal distance from it, the iteration quickly scapes to infinity. You can visualize this as balancing a ball in a pencil. It is possible but the slightest perturbation will make the ball fall. For this reason, you don&rsquo;t see anything if you zoom in this zone of the Mandelbrot set.</p>

<h2 id="let-the-computer-do-its-work">Let the computer do its work</h2>

<p>I&rsquo;m tired of manually calculating this values so lets create some code to do it for us.</p>

<p>First, we need to have a <a href="https://en.wikipedia.org/wiki/Mandelbrot_set#Formal_definition">formal definition</a> of the Mandelbrot set. This can be obtained from wikipedia.</p>

<p>$$ z_{n+1} = z^2_n+c $$</p>

<p>$$ c ∈ M ↔ limsup_{z-&gt;∞}|z_{n+1}| &lt; 2 $$</p>

<p>The important information here is that we already know the condition of &ldquo;diverge&rdquo;. When de module of the value z is bigger than 2, we know that the point is not in the set.</p>

<h3 id="mandelbrot-point">Mandelbrot point</h3>

<p>I&rsquo;m going to create a structure mandelbrot.Point to hold the necessary information to calculate any given point of the set. This will contain the methods Calculate, Diverges and Iterations.</p>

<pre><code class="language-go">package mandelbrot

import ()

type Point struct {
  Point      complex128
  iterations int
  z          complex128
}

// NewPoint returns a new point at a given coordenates
func NewPoint(r, i float64) *Point {
  return &amp;Point{
    Point: complex(r, i),
  }
}

// Calculate performs as many calculations as MaxIterations to determine if the point belongs to the set or not
func (m *Point) Calculate(MaxIterations int) {
  panic(&quot;To be implemented&quot;)
}

// Diverges returns whether the points diverges from the set.
func (m *Point) Diverges() bool {
  panic(&quot;To be implemented&quot;)
}

// Iterations returns the number of performed iterations.
func (m *Point) Iterations() int {
  return m.Iterations()
}
</code></pre>

<p>it is time to write tests to develop this functionality. TDD fits really well in cases like this were we already have a clear definition of what are all the outputs.</p>

<pre><code class="language-go">package mandelbrot_test

import (
  &quot;testing&quot;

  . &quot;github.com/metalblueberry/mandelbrot/mandelbrot&quot;
)

type testMandelbrotPointCases struct {
  point      *Point
  iterations int
  diverges   bool
}

func TestMandelbrotPoint(t *testing.T) {
  tests := []testMandelbrotPointCases{
    testMandelbrotPointCases{
      point:      NewPoint(1, 0),
      iterations: 100,
      diverges:   true,
    },
    testMandelbrotPointCases{
      point:      NewPoint(-1, 0),
      iterations: 100,
      diverges:   false,
    },
    testMandelbrotPointCases{
      point:      NewPoint(-0.5, 0.5),
      iterations: 100,
      diverges:   false,
    },
    testMandelbrotPointCases{
      point:      NewPoint(0, 1),
      iterations: 100,
      diverges:   true,
    },
  }

  for i, test := range tests {
    t.Log(test)
    test.point.Calculate(test.iterations)
    if test.point.Diverges() != test.diverges {
      t.Errorf(&quot;Test %d failed, Point %f diverges %t expected %t&quot;, i, test.point.Point, test.point.Diverges(), test.diverges)
    }
  }
}

</code></pre>

<blockquote>
<p>You may notice that the point <code>(0,1)</code> is expected to diverge but we already know that this is a special case that does not diverge. If you debug the program, you will notice that it diverges after a few iterations due to numerical errors. This is not a problem though, the representation of the set is still perfectly fine.</p>
</blockquote>

<p>The code is in fact really simple with go because there is support for complex numbers that handles all the special cases with $i^2$</p>

<pre><code class="language-go">func (m *Point) Calculate(MaxIterations int) {
  for !m.Diverges() &amp;&amp; m.iterations &lt; MaxIterations {
    m.iterations++
    m.z = cmplx.Pow(m.z, 2) + m.Point
    log.Printf(&quot;z_%d=%f\n&quot;, m.iterations, m.z)
  }
}

func (m *Point) Diverges() bool {
  return cmplx.Abs(m.z) &gt; complex(2, 0)
}
</code></pre>

<div class="expand">
    <div class="expand-label" id="expand-label-0" style="cursor: pointer;">
        <span>
            
            
            Click here to see all code
            
        </span>
    </div>
    <div class="expand-content" id="expand-content-0" style="display: none;">
        <pre><code class="language-go">package mandelbrot

import (
  &quot;log&quot;
  &quot;math/cmplx&quot;
)

type Point struct {
  Point      complex128
  iterations int
  z          complex128
}

// NewPoint returns a new point at a given coordenates
func NewPoint(r, i float64) *Point {
  return &amp;Point{
    Point: complex(r, i),
  }
}

// Calculate performs as many calculations as MaxIterations to determine if the point belongs to the set or not
func (m *Point) Calculate(MaxIterations int) {
  for !m.Diverges() &amp;&amp; m.iterations &lt; MaxIterations {
    m.iterations++
    m.z = cmplx.Pow(m.z, 2) + m.Point
    log.Printf(&quot;z_%d=%f\n&quot;, m.iterations, m.z)
  }
}

// Diverges returns whether the points diverges from the set.
func (m *Point) Diverges() bool {
  return cmplx.Abs(m.z) &gt; complex(2, 0)
}

// Iterations returns the number of performed iterations.
func (m *Point) Iterations() int {
  return m.Iterations()
}
</code></pre>
    </div>
    <script>
        function collapse(e) {
            e = e || window.event;
            var target = e.target || e.srcElement,
                text = target.textContent || target.innerText;

            console.log("event received")
            console.log(target)

            target.classList.toggle("active");
            var content = this.nextElementSibling;
            console.log(content)
            console.log(content.style.display)
            if (content.style.display === "block") {
                content.style.display = "none";
                console.log(content.style.display)
            } else {
                content.style.display = "block";
            }
        }
        document.getElementById("expand-label-0").addEventListener("click", collapse);
    </script>
</div>

<h3 id="mandelbrot-set">Mandelbrot set</h3>

<p>The mandelbrot.Set will hold all the mandelbrot.Points. To ease the usage, I&rsquo;ve added a constructor of rectangular Areas centered at a given point. This will come handy when zooming in the future.</p>

<pre><code class="language-go">type Area struct {
  HorizontalResolution int
  VerticalResolution   int
  TopLeft              complex128
  BottomRight          complex128
  MaxIterations        int
  Points               []Point
}

//NewAreaCentered creates a mandelbrot.Area with squared shape centered area at x,y of width = 2*area
func NewAreaCentered(Resolution, MaxIterations int, x, y, area float64) *Area {
  return &amp;Area{
    HorizontalResolution: Resolution,
    VerticalResolution:   Resolution,
    MaxIterations:        MaxIterations,
    TopLeft:              complex(x-area, y+area),
    BottomRight:          complex(x+area, y-area),
    Points:               make([]Point, Resolution*Resolution),
  }
}
</code></pre>

<p>You may notice that the <code>Points</code> variable is a single dimension array. The idea behind this is to have a single memory allocation for all the data. This will increase the difficulty to index a given point, but we will easily solve this by two helper methods <code>ForIndex</code> and <code>IndexFor</code> that will server to obtain the valid index for a given x,y coordinates and the x,y coordinates of a given index.</p>

<pre><code class="language-go">func (a *Area) IndexFor(x, y int) int {
  return x + y*a.HorizontalResolution
}

func (a *Area) ForIndex(i int) (x, y int) {
  y = i / a.VerticalResolution
  x = i % a.HorizontalResolution
  return x, y
}
</code></pre>

<p>Before using the Area, we need to initialize the Points array depending on the resolution. For this purpose let&rsquo;s add a method <code>Init</code> to the struct that for each point. To get the complex number for a x,y position, I&rsquo;m creating the method <code>getNumber</code>. So in the <code>Init</code> method I&rsquo;m iterating over all the pixels defined by the resolution getting a NewPoint for each one.</p>

<pre><code class="language-go">func (a *Area) getNumber(x, y int) (r, i float64) {
  TopLeftReal := real(a.TopLeft)
  TopLeftImag := imag(a.TopLeft)
  BottomRightReal := real(a.BottomRight)
  BottomRightImag := imag(a.BottomRight)

  r = TopLeftReal + (float64(x)/float64(a.HorizontalResolution))*(BottomRightReal-TopLeftReal)
  i = TopLeftImag + (float64(y)/float64(a.VerticalResolution))*(BottomRightImag-TopLeftImag)
  return r, i
}

func (a *Area) Init() {
  for x := 0; x &lt; a.HorizontalResolution; x++ {
    for y := 0; y &lt; a.VerticalResolution; y++ {
      point := NewPoint(a.getNumber(x, y))
      a.SetPoint(x, y, point)
    }
  }
}
</code></pre>

<p>Now I&rsquo;m going to create a <code>Calculate</code> method to start the computational task. As it will be a long process, I want to do it in a separate go routine and have some kind of progress give feedback to the main thread. The method returns a channel that we can read to get the point that has been just analyzed by the function and we can divide this by the total count to know the overall progress. I don&rsquo;t want the function to get blocked if the user is not reading the progress channel and that is why you see the select block at the end of the for loop. Another think is that the Points variable is a slice of struct, this means that we need to reassign the value in order to update the content of the slice.</p>

<pre><code class="language-go">func (a *Area) Calculate() (progress chan int) {
  progress = make(chan int)
  go func() {
    defer close(progress)
    for i, pixel := range a.Points {
      pixel.Calculate(a.MaxIterations)
      a.Points[i] = pixel

      select {
      case progress &lt;- i:
      default:
      }
    }
  }()
  return
}
</code></pre>

<div class="expand">
    <div class="expand-label" id="expand-label-1" style="cursor: pointer;">
        <span>
            
            
            Click here to see all code
            
        </span>
    </div>
    <div class="expand-content" id="expand-content-1" style="display: none;">
        <pre><code class="language-go">package mandelbrot

type Area struct {
  HorizontalResolution int
  VerticalResolution   int
  TopLeft              complex128
  BottomRight          complex128
  MaxIterations        int
  Points               []Point
}

func NewAreaCentered(Resolution, MaxIterations int, x, y, area float64) *Area {
  return &amp;Area{
    HorizontalResolution: Resolution,
    VerticalResolution:   Resolution,
    MaxIterations:        MaxIterations,
    TopLeft:              complex(x-area, y+area),
    BottomRight:          complex(x+area, y-area),
    Points:               make([]Point, Resolution*Resolution),
  }
}

func (a *Area) Init() {
  for x := 0; x &lt; a.HorizontalResolution; x++ {
    for y := 0; y &lt; a.VerticalResolution; y++ {
      point := NewPoint(a.getNumber(x, y))
      a.SetPoint(x, y, point)
    }
  }
}

func (a *Area) Calculate() (progress chan int) {
  progress = make(chan int)
  go func() {
    defer close(progress)
    for i, pixel := range a.Points {
      pixel.Calculate(a.MaxIterations)
      a.Points[i] = pixel

      select {
      case progress &lt;- i:
      default:
      }
    }
  }()
  return
}

func (a *Area) IndexFor(x, y int) int {
  return x + y*a.HorizontalResolution
}

func (a *Area) ForIndex(i int) (x, y int) {
  y = i / a.VerticalResolution
  x = i % a.HorizontalResolution
  return x, y
}

// SetPoint changes the address of the point located at x,y
func (a *Area) SetPoint(x, y int, p Point) {
  a.Points[a.IndexFor(x, y)] = p
}

// GetPoint changes the address of the point located at x,y
func (a *Area) GetPoint(x, y int) Point {
  return a.Points[a.IndexFor(x, y)]
}

// getNumber gives the real and imaginary parts for the complex number located at the given x,y coordenates in the given resolution.
func (a *Area) getNumber(x, y int) (r, i float64) {
  TopLeftReal := real(a.TopLeft)
  TopLeftImag := imag(a.TopLeft)
  BottomRightReal := real(a.BottomRight)
  BottomRightImag := imag(a.BottomRight)

  r = TopLeftReal + (float64(x)/float64(a.HorizontalResolution))*(BottomRightReal-TopLeftReal)
  i = TopLeftImag + (float64(y)/float64(a.VerticalResolution))*(BottomRightImag-TopLeftImag)
  return r, i
}
</code></pre>
    </div>
    <script>
        function collapse(e) {
            e = e || window.event;
            var target = e.target || e.srcElement,
                text = target.textContent || target.innerText;

            console.log("event received")
            console.log(target)

            target.classList.toggle("active");
            var content = this.nextElementSibling;
            console.log(content)
            console.log(content.style.display)
            if (content.style.display === "block") {
                content.style.display = "none";
                console.log(content.style.display)
            } else {
                content.style.display = "block";
            }
        }
        document.getElementById("expand-label-1").addEventListener("click", collapse);
    </script>
</div>

<h2 id="generate-mandelbrot-data">Generate Mandelbrot Data</h2>

<p>Now it is time to generate a simple main program to calculate the data for a given section of the complex number space. I&rsquo;m going to use the image package to generate a png file of the given section and write it to the standard output. I&rsquo;ve chosen a squared area centered at <code>(-0.5, 0)</code> of size 1.5 with 5000x5000 resolution using 200 iterations at maximum.</p>

<p>After calling <code>set.Calculate</code> I&rsquo;m using range progress to get the updates and to print feedback to Stderr. To avoid printing a line for every pixel, I&rsquo;ve added a <code>&lt;-time.After(time.Second * 1)</code> to limit the prints to 1 per second.</p>

<p>The process of generating the image is as simple as initializing it with the Horizontal and Vertical resolutions and then fill each pixel using the method <code>setRGBA</code>. I&rsquo;m not using any complex algorithm for choosing the color. For simplicity I&rsquo;m just using red and the intensity depends on the iterations needed to tell if the point belongs to the set or not. the more iterations, the darker the color. That&rsquo;s why the points that belong to the set are black.</p>

<pre><code class="language-go">package main

import (
  &quot;fmt&quot;
  &quot;image&quot;
  &quot;image/color&quot;
  &quot;image/jpeg&quot;
  &quot;os&quot;
  &quot;time&quot;

  &quot;github.com/metalblueberry/mandelbrot/mandelbrot&quot;
)

func main() {
  set := mandelbrot.NewAreaCentered(5000, 200, -0.5, 0, 1.5)
  set.Init()
  progress := set.Calculate()
  for p := range progress {
    fmt.Fprintf(os.Stderr, &quot;%d\r&quot;, 100*p/len(set.Points))
    &lt;-time.After(time.Second * 1)
  }

  img := image.NewRGBA(image.Rect(0, 0, set.HorizontalResolution, set.VerticalResolution))

  for x := 0; x &lt; set.HorizontalResolution; x++ {
    for y := 0; y &lt; set.VerticalResolution; y++ {
      point := set.GetPoint(x, y)
      intensity := 255 - (255 * point.Iterations() / set.MaxIterations)
      img.SetRGBA(x, y, color.RGBA{R: uint8(intensity), A: 255})
    }
  }
  err := jpeg.Encode(os.Stdout, img, &amp;jpeg.Options{Quality: 90})
  if err != nil {
    panic(err)
  }
}
</code></pre>

<p>Now you can build or run the code directly and pipe the Stdout to a png file. This code generates the following image.</p>

<p><img src="./mandelbrot.jpeg" alt="mandelbrot-img" /></p>

<p>And with just modifying the input parameters, we can zoom in a given section. For example, this image is generated from the following input.</p>

<pre><code class="language-go">mandelbrot.NewAreaCentered(5000, 350, -0.7463, 0.1102, 0.005)
</code></pre>

<p><img src="./mandelbrot_-07463_01102_0005.jpeg" alt="mandelbrot-zoom" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>I&rsquo;ve plans to keep improving this code. In one hand, I would like to create an API to send the image data to a web browser. Then we will be able to use JS to build a simple viewer to ease the work of requesting zooms in a given area. In the other hand, I would like to speedup the calculation by splitting the area in chunks and compute them in parallel.</p>

<p>You can explore the repository to see the whole code and to play with it <a href="https://github.com/MetalBlueberry/go-mandelbrot/tree/2019-10-31_mandelbrot-set-calculation">here</a>.</p>

<p>Thank you for reading and feel free to leave a comment bellow, I will be really happy to hear from you.</p>

<h2 id="references-and-links">References and Links</h2>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Mandelbrot_set">wikipedia</a></li>
<li><a href="https://sciencedemos.org.uk/mandelbrot.php">Interactive Mandelbrot Zoom</a></li>
<li><a href="https://www.youtube.com/watch?v=PD2XgQOyCCk">Incredible zoom video</a></li>
</ul></article><section class="article labels"><a class="category" href=/categories/howto/>howto</a><a class="tag" href=/tags/go/>go</a><a class="tag" href=/tags/mandelbrot/>mandelbrot</a></section></div><section class="article navigation"><p><a class="link" href="/post/howto/2019-11-01_go-cpu-profiling/"><span class="li">&larr;</span>Go CPU profiling</a></p><p><a class="link" href="/post/howto/2019-10-29_create-a-blog-like-this/"><span class="li">&rarr;</span>Create a Blog Like This</a></p></section><script src="https://utteranc.es/client.js" repo="MetalBlueberry/MetalBlueberry.github.io" issue-term="og:title"
    label="comment" theme="github-light" crossorigin="anonymous" async>
    </script></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Víctor Pérez Domingo</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150427130-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</body>

</html>