<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.59.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Mandelbrot Parallel Computation&nbsp;&ndash;&nbsp;MetalBlueberry</title><link rel="stylesheet" href="/css/core.min.97dca4f10b4a76a5c62d6c5855e9eaab3b083ba20b6e4059f24dc20a8bb331c418ecdfd5449a29ef5333ebc2c64b286b.css" integrity="sha384-l9yk8QtKdqXGLWxYVenqqzsIO6ILbkBZ8k3CCouzMcQY7N/VRJop71Mz68LGSyhr"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mandelbrot Parallel Computation"/>
<meta name="twitter:description" content="This post explains how to parallelize the computational task of the Mandelbrot set and generate a terminal tool to generate images."/>

<meta property="og:title" content="Mandelbrot Parallel Computation" />
<meta property="og:description" content="This post explains how to parallelize the computational task of the Mandelbrot set and generate a terminal tool to generate images." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://metalblueberry.github.io/post/howto/2019-11-17_mandelbrot_parallel_computation/" />
<meta property="article:published_time" content="2019-11-17T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-10T11:39:35+02:00" />

<meta name="author" content="MetalBlueberry">

<script src="https://cdn.plot.ly/plotly-1.50.0.min.js"></script>
<body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/android-chrome-512x512.png" alt /><span class="site name">MetalBlueberry</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/about">About</a><a class="nav item" href="/social">Follow me</a></nav></div></span></div><div class="site slogan"><span class="title">A passionate programmer</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Mandelbrot Parallel Computation</h1><p class="article date">Sunday, November 17, 2019<span class="lastmod"> • edited Friday, April 10, 2020</span></p></section><article class="article markdown-body"><p>This post explains how to parallelize the computational task of the Mandelbrot set and generate a terminal tool to generate images.</p>

<div class="admonition warning"><p class="admonition-title">warning</p>
  
<p>You should read <a href="/post/howto/2019-11-01_go-cpu-profiling/">the previous post</a> to understand the context of this post.</p>


</div>

<p>We left it after improving drastically the performance of our code by running benchmarks and drawing flame graphs with pprof. The problem is we almost hit the limit of the optimization following this line. Now we are going to take advantage of the tools provided by Go to implement a parallel computation that will reduce the total computational time.</p>

<h2 id="introduction">Introduction</h2>

<p>The first thing to do is to identify the parts of the computation that can be calculated independently from the others. Luckily, in the Mandelbrot set, the calculation if each point belongs to the set, is completely independent from other points. This makes really simple to split the work over multiple cores.</p>

<p>Next think to ask ourself is, is it worth to spawn a goroutine for each point? Reading documentation about go internals, this can be done, but it is not a good practice. This is because the task that we are performing is CPU intensive and this will effectively limit the maximum number of goroutines running to the maximum number of available cores in the system. So, theoretically, the maximum number of routines should be the number of cores.</p>

<p>Knowing that this encourages a producer-consumer pattern. The next questions is, what is the optimal way to split the tasks? we know that the calculation for each point is the minium part that can be calculated independently. Should we group some points as a single task? if yes, how many? I think the best way to answer this question is to benchmark the code.</p>

<div class="admonition info"><p class="admonition-title">Info</p>
  
<p>The idea that I&rsquo;ve in mind comes from how Blender renders complex images. here is a gif of a render divided in little squares.</p>

<p><img src="https://devtalk.blender.org/uploads/default/original/1X/79d5a6dd63de7dead05d73e29ed263f66f43af16.gif#center" alt="blenderrender" /></p>


</div>

<h2 id="the-mandelbrot-picture-struct">The Mandelbrot Picture Struct</h2>

<p>To hold the data together and to coordinate the calculation, I&rsquo;ve created a new structure called Picture. Then, we have a <code>mandelbot.Point</code>, as the minimal computational unit. <code>mandelbot.Area</code>, as a group of Points that will be calculated together. And <code>mandelbot.Picture</code> as a group of Areas.</p>

<p><img src="./Picture Description.svg#center" alt="Picture Description" /></p>

<p>The previous picture is a visual representation of what the variables of the Picture structure actually mean. Blue ones are in pixels and represent the final image that will be build. The red ones are in float point precision and represent the mandelbrot area. The axis are just there as an orientation</p>

<pre><code class="language-go">type Picture struct {
	TopLeft       complex128
	ChunkSize     float64
	MaxIterations int

	HorizontalImageChunks int
	VerticalImageChunks   int
	ChunkImageSize        int

	areas []Area
}
</code></pre>

<p>The strategy of storing 2D data in a single array is also being used here with exactly the same approach. To initialize the data, I also have the <code>picture.Init</code> function that initializes the picture and all the recursive areas. This function performs the calculation to assign to each area the corresponding section of the complex area that must render. Based on the x,y position and the ChunkSize, it is easy to calculate the TopLeft and BottomRight of each area. The only tricky thing is that to move from TopToBottom, we need to subtract instead of adding. thats why you see the minus sign next to the imaginary parts. Also, after creating the Area with the calculated values, there is a call to <code>area.Init</code> to guarantee that everything is initialised.</p>

<pre><code class="language-go">func (p *Picture) Init() {
	p.areas = make([]Area, p.HorizontalImageChunks*p.VerticalImageChunks)
	for i := 0; i &lt; len(p.areas); i++ {
		x, y := p.ForIndex(i)
		areaTopLeft := p.TopLeft + complex(p.ChunkSize*float64(x), -p.ChunkSize*float64(y))
		areaBottomRight := areaTopLeft + complex(p.ChunkSize, -p.ChunkSize)

		p.areas[i] = Area{
			TopLeft:              areaTopLeft,
			BottomRight:          areaBottomRight,
			HorizontalResolution: p.ChunkImageSize,
			VerticalResolution:   p.ChunkImageSize,
			MaxIterations:        p.MaxIterations,
		}
		p.areas[i].Init()
	}
}
</code></pre>

<h2 id="calculation">Calculation</h2>

<p>Let&rsquo;s start with a simple loop to calculate all the areas inside the Picture. It will look like this.</p>

<pre><code class="language-go">func (p *Picture) Calculate() {
	for i := 0; i &lt; len(p.areas); i++ {
		p.areas[i].Calculate()
	}
}
</code></pre>

<p>The firs way is to decide how are we going to split the areas slice for the workers. <strong>My first attempt</strong> was to slice the slice intro subparts with the same number of elements, but this approach has a few drawbacks. First, when the operation len(p.areas)/workers generates a remained, it becomes tricky which worker should do it. Also, not all the areas require the same number of iterations, so this approach generates unbalanced workers. This is how the code looks like</p>

<pre><code class="language-go">func (p *Picture) Calculate(workerCount int) {
	works := splitWorks(p.areas, workerCount)

	for w := 0; w &lt; len(p.works); w++ {
		go doWork(works[w])
	}
}

func splitWorks(areas []Area, workerCount int) (works [][]Area) {
	// Split []Area in [][]Area, omitted for simplicity
}

func doWork(areas []Area){
	for i := 0; i &lt; len(p.areas); i++ {
		areas[i].Calculate()
	}
}
</code></pre>

<h3 id="task-synchronization-with-sync-waitgroup">Task Synchronization With sync.WaitGroup</h3>

<p>The firs issue with this code is that the Calculate function no longer blocks the code and it exist before the computation finishes. To address this issue, we have <code>sync.WaitGroup</code>. A wait group is a simple structure that keeps track of the works that are being executed in parallel and allows easy synchronization to wait for all of them to finish. After creating the <code>wg := &amp;sync.WaitGroup{}</code>, you must call to <code>wg.Add</code> with the number of expected workers and then, call <code>wg.Done</code> when each of the workers finish. This allows to wait for all of them to exit with a simple call to <code>wg.Wait</code></p>

<pre><code class="language-go">func (p *Picture) Calculate(workerCount int) {
	// Setup wg and WorkerCount
	wg := &amp;sync.WaitGroup{}
	wg.Add(workerCount)

	works := splitWorks(p.areas, workers)

	for w := 0; w &lt; len(p.works); w++ {
		// send the wg to the worker
		go doWork(wg, works[w])
	}
	// Wait for all the workers to finish
	wg.Wait()
}

func splitWorks(areas []Area, workers int) (works [][]Area) {
	// Split []Area in [][]Area, omitted for simplicity
}

func doWork(wg *sync.WaitGroup, areas []Area){
	// when the work is done, notify the wg
	defer wg.Done()
	for i := 0; i &lt; len(p.areas); i++ {
		areas[i].Calculate()
	}
}
</code></pre>

<h3 id="work-queue">Work Queue</h3>

<p>I&rsquo;m not really happy with the approach of splitting the work for the various reasons I&rsquo;ve described before. In the <strong>second attempt</strong>, I decided to generate queue with all the areas pending to be processed and the workers just pick new jobs from there until all are done. Let&rsquo;s create the function to initialize the queue based on a channel.</p>

<pre><code class="language-go">func workQueue(workCount int) &lt;-chan int {
	next := make(chan int)
	go func() {
		for i := 0; i &lt; workCount; i++ {
			next &lt;- i
		}
		close(next)
	}()
	return next
}
</code></pre>

<p>Given a workCount, this function returns a channel that returns sequentially the numbers from 0 to workCount - 1. This fits perfectly to the indexes of a slice and this is how we are going to use it. First, we have to modify our workers to accept the work from a channel.</p>

<pre><code class="language-go">func doWork(wg *sync.WaitGroup, areas []Area, next &lt;-chan int){
	defer wg.Done()

	for i := range next {
		areas[i].Calculate()
	}
}
</code></pre>

<p>The range function used over a channel, returns elements until the channel is closed. This is really handy to implement the work queue. The code looks even easier than before. Let&rsquo;s see all together.</p>

<pre><code class="language-go">func (p *Picture) Calculate(workerCount int) {
	wg := &amp;sync.WaitGroup{}
	wg.Add(workerCount)

	next := workQueue(len(p.areas))

	for worker := 0; worker &lt; workerCount; worker++ {
		go doWork(wg, p.areas, next)
	}

	wg.Wait()

}

func workQueue(workCount int) &lt;-chan int {
	next := make(chan int)
	go func() {
		for i := 0; i &lt; workCount; i++ {
			next &lt;- i
		}
		close(next)
	}()
	return next
}

func doWork(wg *sync.WaitGroup, areas []Area, next &lt;-chan int) {
	defer wg.Done()
	for i := range next {
		areas[i].Calculate()
	}
}
</code></pre>

<h3 id="work-progress-report">Work Progress Report</h3>

<p>Remember when we tried to implement progress reporting using channels and this drastically reduced the performance? well, It was clearly over engineered to report every iteration of the calculation. But with this new structure, it would be easy and cheap to report each time one of the workers finish the calculation of an area. This will enable potential consumers to start drawing it or just notify us of the global process. I will be using the same approach as the workQueue. The calculate function will return a channel that reports the updates. To keep things clear, I will also create the method <code>picture.CalculateAsync</code> to create the channel for the consumer.</p>

<pre><code class="language-go">func (p *Picture) Calculate(ctx context.Context, workerCount int, doneIndex chan&lt;- int) {
	wg := &amp;sync.WaitGroup{}
	wg.Add(workerCount)

	next := workQueue(ctx, len(p.areas))

	for worker := 0; worker &lt; workerCount; worker++ {
		go doWork(wg, p.areas, next, doneIndex)
	}

	wg.Wait()

	close(doneIndex)
}

func (p *Picture) CalculateAsync(ctx context.Context, workerCount int) &lt;-chan int {
	doneIndex := make(chan int)
	go p.Calculate(ctx, workerCount, doneIndex)
	return doneIndex
}

func workQueue(ctx context.Context, workCount int) &lt;-chan int {
	next := make(chan int)
	go func() {
		for i := 0; i &lt; workCount; i++ {
			next &lt;- i
		}
		close(next)
	}()
	return next
}

func doWork(wg *sync.WaitGroup, areas []Area, next &lt;-chan int, doneIndex chan&lt;- int) {
	defer wg.Done()
	for i := range next {
		areas[i].Calculate()
		doneIndex &lt;- i
	}
}
</code></pre>

<h3 id="calculation-execution-context">Calculation Execution Context</h3>

<p>The doneIndex channel carries the index of the Area that has been finished. The consumer only needs to wait for a number to arrive, and then, get the corresponding Area from the Picture. We will see this code later. Now we have to add one last thing to this code. The calculation can take a long time or we may require to stop it before finishing. To implement this, we have the <code>context.Context</code>. From the docs <em>A Context carries a deadline, a cancellation signal, and other values across API boundaries.</em> let&rsquo;s see how the code looks like.</p>

<pre><code class="language-go">func (p *Picture) Calculate(ctx context.Context, workerCount int, doneIndex chan&lt;- int) {
	wg := &amp;sync.WaitGroup{}
	wg.Add(workerCount)

	next := workQueue(ctx, len(p.areas))

	for worker := 0; worker &lt; workerCount; worker++ {
		go doWork(wg, p.areas, next, doneIndex)
	}

	wg.Wait()

	close(doneIndex)
}

func (p *Picture) CalculateAsync(ctx context.Context, workerCount int) &lt;-chan int {
	doneIndex := make(chan int)
	go p.Calculate(ctx, workerCount, doneIndex)
	return doneIndex
}

func workQueue(ctx context.Context, workCount int) &lt;-chan int {
	next := make(chan int)
	go func() {
		for i := 0; i &lt; workCount; i++ {
			select {
			case &lt;-ctx.Done():
				return
			case next &lt;- i:
			}
		}
		close(next)
	}()
	return next
}

func doWork(wg *sync.WaitGroup, areas []Area, next &lt;-chan int, doneIndex chan&lt;- int) {
	defer wg.Done()
	for i := range next {
		areas[i].Calculate()
		doneIndex &lt;- i
	}
}
</code></pre>

<p>So the tricky thing here is that the workQueue now has two options. A. Publish a new work to be done to the <code>next</code> channel. B. receive a <code>ctx.Done</code> signal and close the <code>next</code> channel. When B happens. this will stop the workers after they finish the current task. This is not the ideal situation because an external user will expect the function to return almost immediately after context cancellation. The problem is that achieving this, can be a little more trick because we cannot just cancel a running goroutine. Also, we cannot close the <code>doneIndex</code> channel until all the workers have finished their work because, if the channel is closed, the workers will panic when publishing the index after calculation. Nevertheless, It is possible to handle such case with a similar select statement to the one used in the <code>workerQueue</code> and adding another go routine in the calculate function to listen for the <code>wg.Wait()</code>. But I think this is too complex for this case. so I will keep it like this for now.</p>

<h2 id="configuration-and-benchmarks">Configuration And Benchmarks</h2>

<p>We have everything ready run our code in parallel, but there are a lot of different setting configurations that can affect the performance of the calculation. The best way to find the appropriate configuration is to run benchmarks and see where the performance is better.</p>

<p>This is the list of parameters that we can modify to change how the work is going to be processed by the workers.</p>

<ul>
<li>Image dimensions

<ul>
<li>HorizontalImageChunks</li>
<li>VerticalImageChunks</li>
<li>ChunkImageSize</li>
</ul></li>
<li>Workers</li>
</ul>

<p>To keep a constant image size, the following operation must be constant.</p>

<p>$$HorizontalImageChunks*VerticalImageChunks*ChunkImageSize^2$$</p>

<p>Now we need to choose an image size and try all the combinations of these values. I&rsquo;ve started with an image of 1024x1024 in the Mandelbrot area <code>topLeft:(-1.401854499759, -0.000743603637), bottomRight: (−1,180199459759,−0,222398643637)</code>. The most fragmented case is when I divide the image in 1024x1024 areas of 1 pixel and the less fragmented is just 1 area of 1024x1024 pixels. In the following graph you can see the benchmark results for all the power of 2 combinations from the most fragmented to the less fragmented. In the X axis, the numbers of the previous multiplication. in the Y axis, the s/op returned by the benchmark.  The Y axis is in logarithmic scale to improve the visualization. You can hover the mouse over any point to see the exact value. The horizontal lines represent the optimal speed based on the 1 worker benchmark. is expected to get x2 x3 x4 etc&hellip; speed for each extra worker. You also need to know that my computer has 6 cores.</p>

<div class="figure">
<div class="figure-plot" id="figure1">
	Code could not finish, this are some reasons why this happen.
	- Plot name not defined. The first parameter of the shortcode is the name.
	- There is a syntax error. check browser console.
</div>
<script>
  function draw(){
	test = document.getElementById("figure1");
	if (test == null){
		console.log("The plot name is not defined")
		return
	}

	fig = null
	
fig = {"data":[{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[5.319377513,3.730183194,3.492960513,3.416568462,3.406160365,3.404795796,3.401629099,3.403963371,3.406568944,3.403851128,3.401489335],"name":"1 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[5.105426336,2.403512541,1.769243872,1.720678808,1.705878765,1.702246865,1.705907853,1.731687894,1.819791773,1.954560985,3.404077505],"name":"2 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[4.665434148,1.840141806,1.23159353,1.156602142,1.139298289,1.135465838,1.145931396,1.190932724,1.324346159,1.955651422,3.401555276],"name":"3 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[3.277424857,1.508889857,1.000251994,0.877004851,0.855757891,0.851836168,0.859728354,0.902649372,1.012687753,1.955834209,3.404003372],"name":"4 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[2.687810723,1.299930746,0.848919389,0.71687461,0.697146793,0.686797944,0.695021475,0.733307298,0.782258103,1.958691928,3.406197102],"name":"5 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[2.419063112,1.172598442,0.770078822,0.636418239,0.59517132,0.58758251,0.598871324,0.655497364,0.722161112,1.955789037,3.40305645],"name":"6 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[1.991583443,1.033091053,0.712726608,0.605582734,0.578420338,0.577574125,0.580463384,0.652894185,0.691949137,1.970116638,3.452580344],"name":"7 workers"},{"x":["1024x1024x1","512x512x2","256x256x4","128x128x8","64x64x16","32x32x32","16x16x64","8x8x128","4x4x256","2x2x512","1x1x1024"],"y":[1.942149854,0.947873093,0.683032395,0.605635427,0.575207906,0.573205018,0.580969231,0.653116053,0.72285752,1.954330764,3.407772597],"name":"8 workers"}],"layout":{"title":"Benchmark results","yaxis":{"title":"s/op","type":"log","autorange":true},"shapes":[{"type":"line","xref":"paper","yref":"y","y0":3.40394218,"x0":0,"y1":3.40394218,"x1":1,"line":{"width":1}},{"type":"line","xref":"paper","yref":"y","y0":1.70197109,"x0":0,"y1":1.70197109,"x1":1,"line":{"width":1}},{"type":"line","xref":"paper","yref":"y","y0":1.1346473933333334,"x0":0,"y1":1.1346473933333334,"x1":1,"line":{"width":1}},{"type":"line","xref":"paper","yref":"y","y0":0.850985545,"x0":0,"y1":0.850985545,"x1":1,"line":{"width":1}},{"type":"line","xref":"paper","yref":"y","y0":0.680788436,"x0":0,"y1":0.680788436,"x1":1,"line":{"width":1}},{"type":"line","xref":"paper","yref":"y","y0":0.5673236966666667,"x0":0,"y1":0.5673236966666667,"x1":1,"line":{"width":1}}],"margin":{"l":25,"r":5,"b":75,"t":50,"pad":4}},"config":{"responsive":true}}


	if (!fig) {
		test.innerText = "ERROR: fig variable is not defined"
		return
	}
	test.innerText = null
	Plotly.plot(test ,fig);
  }
  draw()
</script>
</div>

<p>There a few interesting things in this graph.</p>

<ol>
<li>If the image only contains 1 area, the benchmark is independent of the number of cores. You can see this at the right point of the graph.</li>
<li>If the image is divided in too many areas. The performance is deteriorated for all the setups. This is the left part of the graph.</li>
<li>All the lines have a parabolic shape with a minimum in 32x32x32. This is the best setup for my computer.</li>
<li>Selecting the minimum point, the performance is doubled almost perfectly for each worker added until reaching the system limit of 6 cores.</li>
<li>The performance still increases after 6 workers, but it never reaches the x6 speed.</li>
<li>The performance in 512x512x2 is the same after the 2nd worker. I think this is because not all the sections in the set are equally expensive to calculate. The hardest one is closer to the right top because is almost all black.</li>
</ol>

<p>Here is the code that runs the benchmarks.</p>

<pre><code class="language-go">func benchmarkComplexPictureChunks(b *testing.B, HorizontalImageChunks, VerticalImageChunks, ChunkImageSize, workers int) {
	for i := 0; i &lt; b.N; i++ {
		b.StopTimer()
		pic := &amp;mandelbrot.Picture{
			TopLeft:               complex(-1.401854499759, -0.000743603637),
			MaxIterations:         3534,
			ChunkSize:             0.00021646 * float64(ChunkImageSize),
			HorizontalImageChunks: HorizontalImageChunks,
			VerticalImageChunks:   VerticalImageChunks,
			ChunkImageSize:        ChunkImageSize,
		}
		ctx := context.Background()
		pic.Init()
		b.StartTimer()

		done := pic.CalculateAsync(ctx, workers)
		for range done {

		}
		if *saveImage {
			b.StopTimer()
			saveImageFrom(pic, fmt.Sprintf(&quot;bench_%d_%d_%d_w_%d.jpeg&quot;, pic.HorizontalImageChunks, pic.VerticalImageChunks, pic.ChunkImageSize, workers))
		}
	}
}
</code></pre>

<div class="expand">
    <div class="expand-label" id="expand-label-3" style="cursor: pointer;">
        <span>
            
            
            Click here to see all code
            
        </span>
    </div>
    <div class="expand-content" id="expand-content-3" style="display: none;">
        <pre><code class="language-go">var saveImage = flag.Bool(&quot;saveImage&quot;, false, &quot;save the result of running the benchmarks&quot;)

func benchmarkComplexPictureChunks(b *testing.B, HorizontalImageChunks, VerticalImageChunks, ChunkImageSize, workers int) {
	for i := 0; i &lt; b.N; i++ {
		b.StopTimer()
		pic := &amp;mandelbrot.Picture{
			TopLeft:               complex(-1.401854499759, -0.000743603637),
			MaxIterations:         3534,
			ChunkSize:             0.00021646 * float64(ChunkImageSize),
			HorizontalImageChunks: HorizontalImageChunks,
			VerticalImageChunks:   VerticalImageChunks,
			ChunkImageSize:        ChunkImageSize,
		}
		ctx := context.Background()
		pic.Init()
		b.StartTimer()

		done := pic.CalculateAsync(ctx, workers)
		for range done {

		}
		if *saveImage {
			b.StopTimer()
			saveImageFrom(pic, fmt.Sprintf(&quot;bench_%d_%d_%d_w_%d.jpeg&quot;, pic.HorizontalImageChunks, pic.VerticalImageChunks, pic.ChunkImageSize, workers))
		}
	}
}

func saveImageFrom(pic *mandelbrot.Picture, name string) {
	img := image.NewRGBA(image.Rect(0, 0, pic.HorizontalResolution(), pic.VerticalResolution()))
	for i := 0; i &lt; pic.HorizontalImageChunks*pic.VerticalImageChunks; i++ {
		offsetX, offsetY := pic.GetImageOffsetFor(i)
		paintAreaInImage(img, pic.GetArea(i), offsetX, offsetY)
	}
	outFile, err := os.Create(name)
	if err != nil {
		log.Fatalf(&quot;output file cannot be opened, cause: %s&quot;, err)
	}
	defer outFile.Close()

	encodingError := jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})
	if encodingError != nil {
		panic(err)
	}
}

func paintAreaInImage(img *image.RGBA, area mandelbrot.Area, offsetX int, offsetY int) {
	for x := 0; x &lt; area.HorizontalResolution; x++ {
		for y := 0; y &lt; area.VerticalResolution; y++ {
			point := area.GetPoint(x, y)
			color := getColor(point, []color.RGBA{
				color.RGBA{
					R: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					A: 255,
				},
				color.RGBA{
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					B: 255,
					A: 255,
				},
			}, area.MaxIterations, color.RGBA{
				A: 255,
			})
			img.SetRGBA(offsetX+x, offsetY+y, color)
		}
	}
}
func getColor(point mandelbrot.Point, palette []color.RGBA, maxIterations int, maxIterationsColor color.RGBA) color.RGBA {
	if point.Iterations() == maxIterations {
		return maxIterationsColor
	}
	index := point.Iterations() % len(palette)
	return palette[index]
}
func BenchmarkComplexPictureChunks1024x1024x1w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 1)
}
func BenchmarkComplexPictureChunks512x512x2w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 1)
}
func BenchmarkComplexPictureChunks256x256x4w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 1)
}
func BenchmarkComplexPictureChunks128x128x8w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 1)
}
func BenchmarkComplexPictureChunks64x64x16w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 1)
}
func BenchmarkComplexPictureChunks32x32x32w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 1)
}
func BenchmarkComplexPictureChunks16x16x64w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 1)
}
func BenchmarkComplexPictureChunks8x8x128w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 1)
}
func BenchmarkComplexPictureChunks4x4x256w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 1)
}
func BenchmarkComplexPictureChunks2x2x512w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 1)
}
func BenchmarkComplexPictureChunks1x1x1024w1(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 1)
}

func BenchmarkComplexPictureChunks1024x1024x1w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 2)
}
func BenchmarkComplexPictureChunks512x512x2w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 2)
}
func BenchmarkComplexPictureChunks256x256x4w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 2)
}
func BenchmarkComplexPictureChunks128x128x8w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 2)
}
func BenchmarkComplexPictureChunks64x64x16w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 2)
}
func BenchmarkComplexPictureChunks32x32x32w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 2)
}
func BenchmarkComplexPictureChunks16x16x64w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 2)
}
func BenchmarkComplexPictureChunks8x8x128w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 2)
}
func BenchmarkComplexPictureChunks4x4x256w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 2)
}
func BenchmarkComplexPictureChunks2x2x512w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 2)
}
func BenchmarkComplexPictureChunks1x1x1024w2(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 2)
}

func BenchmarkComplexPictureChunks1024x1024x1w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 3)
}
func BenchmarkComplexPictureChunks512x512x2w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 3)
}
func BenchmarkComplexPictureChunks256x256x4w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 3)
}
func BenchmarkComplexPictureChunks128x128x8w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 3)
}
func BenchmarkComplexPictureChunks64x64x16w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 3)
}
func BenchmarkComplexPictureChunks32x32x32w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 3)
}
func BenchmarkComplexPictureChunks16x16x64w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 3)
}
func BenchmarkComplexPictureChunks8x8x128w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 3)
}
func BenchmarkComplexPictureChunks4x4x256w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 3)
}
func BenchmarkComplexPictureChunks2x2x512w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 3)
}
func BenchmarkComplexPictureChunks1x1x1024w3(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 3)
}

func BenchmarkComplexPictureChunks1024x1024x1w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 4)
}
func BenchmarkComplexPictureChunks512x512x2w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 4)
}
func BenchmarkComplexPictureChunks256x256x4w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 4)
}
func BenchmarkComplexPictureChunks128x128x8w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 4)
}
func BenchmarkComplexPictureChunks64x64x16w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 4)
}
func BenchmarkComplexPictureChunks32x32x32w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 4)
}
func BenchmarkComplexPictureChunks16x16x64w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 4)
}
func BenchmarkComplexPictureChunks8x8x128w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 4)
}
func BenchmarkComplexPictureChunks4x4x256w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 4)
}
func BenchmarkComplexPictureChunks2x2x512w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 4)
}
func BenchmarkComplexPictureChunks1x1x1024w4(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 4)
}

func BenchmarkComplexPictureChunks1024x1024x1w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 5)
}
func BenchmarkComplexPictureChunks512x512x2w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 5)
}
func BenchmarkComplexPictureChunks256x256x4w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 5)
}
func BenchmarkComplexPictureChunks128x128x8w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 5)
}
func BenchmarkComplexPictureChunks64x64x16w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 5)
}
func BenchmarkComplexPictureChunks32x32x32w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 5)
}
func BenchmarkComplexPictureChunks16x16x64w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 5)
}
func BenchmarkComplexPictureChunks8x8x128w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 5)
}
func BenchmarkComplexPictureChunks4x4x256w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 5)
}
func BenchmarkComplexPictureChunks2x2x512w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 5)
}
func BenchmarkComplexPictureChunks1x1x1024w5(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 5)
}

func BenchmarkComplexPictureChunks1024x1024x1w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 6)
}
func BenchmarkComplexPictureChunks512x512x2w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 6)
}
func BenchmarkComplexPictureChunks256x256x4w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 6)
}
func BenchmarkComplexPictureChunks128x128x8w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 6)
}
func BenchmarkComplexPictureChunks64x64x16w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 6)
}
func BenchmarkComplexPictureChunks32x32x32w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 6)
}
func BenchmarkComplexPictureChunks16x16x64w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 6)
}
func BenchmarkComplexPictureChunks8x8x128w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 6)
}
func BenchmarkComplexPictureChunks4x4x256w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 6)
}
func BenchmarkComplexPictureChunks2x2x512w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 6)
}
func BenchmarkComplexPictureChunks1x1x1024w6(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 6)
}

func BenchmarkComplexPictureChunks1024x1024x1w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 7)
}
func BenchmarkComplexPictureChunks512x512x2w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 7)
}
func BenchmarkComplexPictureChunks256x256x4w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 7)
}
func BenchmarkComplexPictureChunks128x128x8w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 7)
}
func BenchmarkComplexPictureChunks64x64x16w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 7)
}
func BenchmarkComplexPictureChunks32x32x32w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 7)
}
func BenchmarkComplexPictureChunks16x16x64w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 7)
}
func BenchmarkComplexPictureChunks8x8x128w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 7)
}
func BenchmarkComplexPictureChunks4x4x256w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 7)
}
func BenchmarkComplexPictureChunks2x2x512w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 7)
}
func BenchmarkComplexPictureChunks1x1x1024w7(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 7)
}
func BenchmarkComplexPictureChunks1024x1024x1w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1024, 1024, 1, 8)
}
func BenchmarkComplexPictureChunks512x512x2w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 512, 512, 2, 8)
}
func BenchmarkComplexPictureChunks256x256x4w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 256, 256, 4, 8)
}
func BenchmarkComplexPictureChunks128x128x8w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 128, 128, 8, 8)
}
func BenchmarkComplexPictureChunks64x64x16w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 64, 64, 16, 8)
}
func BenchmarkComplexPictureChunks32x32x32w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 32, 32, 32, 8)
}
func BenchmarkComplexPictureChunks16x16x64w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 16, 16, 64, 8)
}
func BenchmarkComplexPictureChunks8x8x128w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 8, 8, 128, 8)
}
func BenchmarkComplexPictureChunks4x4x256w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 4, 4, 256, 8)
}
func BenchmarkComplexPictureChunks2x2x512w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 2, 2, 512, 8)
}
func BenchmarkComplexPictureChunks1x1x1024w8(b *testing.B) {
	benchmarkComplexPictureChunks(b, 1, 1, 1024, 8)
}
</code></pre>
    </div>
    <script>
        function collapse(e) {
            e = e || window.event;
            var target = e.target || e.srcElement,
                text = target.textContent || target.innerText;

            console.log("event received")
            console.log(target)

            target.classList.toggle("active");
            var content = this.nextElementSibling;
            console.log(content)
            console.log(content.style.display)
            if (content.style.display === "block") {
                content.style.display = "none";
                console.log(content.style.display)
            } else {
                content.style.display = "block";
            }
        }
        document.getElementById("expand-label-3").addEventListener("click", collapse);
    </script>
</div>

<p>It is important that the caller must read the channel <code>done</code> until the calculation ends because, if there is no receiver, the channel is blocked.</p>

<p>The <code>saveImage</code> is a flag passed to the test command to keep the generated image for each benchmark. This allows to visually verify that the benchmark is actually rendering the right image.</p>

<p>This is the section selected for the benchmarks. I&rsquo;m using a different method to give color to the set this time. I&rsquo;m using a color palette with 7 colors and I assign it based on the number of iterations. <code>color[iterations % len(color)]</code> This is awesome because always give the same color to a section independently of the zoom.</p>

<p><img src="./bench.jpeg" alt="bench" /></p>

<h2 id="mandelbrot-cli">Mandelbrot CLI</h2>

<p>Let&rsquo;s create a CLI to generate awesome images of any given area.</p>

<p>To ease the final usage, I&rsquo;ve simplified the input parameters to some more human-friendly. The default values, generate a global view of the Mandelbrot in a 1920x1920 image.</p>

<pre><code class="language-go">top := flag.Float64(&quot;top&quot;, 1.5, &quot;Top mandelbrot position&quot;)
left := flag.Float64(&quot;left&quot;, -2.1, &quot;Left mandelbrot position&quot;)
areaSize := flag.Float64(&quot;areaSize&quot;, 3, &quot;From the TopLeft, the size of the complex area&quot;)

imageSize := flag.Int(&quot;imageSize&quot;, 1920, &quot;Size of the squared image generated in pixels&quot;)
divisions := flag.Int(&quot;divisions&quot;, 50, &quot;Number of divisions to split the work over multiple routines&quot;)
maxIterations := flag.Int(&quot;maxIterations&quot;, 100, &quot;Maximum number of iterations per point&quot;)

workers := flag.Int(&quot;workers&quot;, runtime.NumCPU(), &quot;Maximum number of iterations per point&quot;)
out := flag.String(&quot;out&quot;, &quot;mandelbrot.jpg&quot;, &quot;output file, it can be png or jpg&quot;)
timeout := flag.Int64(&quot;timeout&quot;, 20, &quot;Maximum number of seconds to compute, if reached. the program will exit&quot;)

</code></pre>

<p>With this flags, I directly call a <code>mandelbot.NewPicture</code> function that accepts this parameters and handles the conversion to the original parameters needed by the <code>mandelbot.Picture</code>. The only thing to adjust is the chunkSize based on the number of divisions to ensure that we draw the same area. The drawback is that we need to carefully select the number of divisions or it will be impossible to split the area in a whole number of divisions.</p>

<pre><code class="language-go">pic := mandelbrot.NewPicture(complex(*left, *top), *areaSize, *imageSize, *divisions, *maxIterations)

func NewPicture(topLeft complex128, chunkSize float64, imageSize int, divisions int, maxIterations int) *Picture {
	if imageSize%divisions != 0 {
		log.Printf(&quot;WARNING: ImageSize %d can't be divided in %d divisions, The final image will be smaller&quot;, imageSize, divisions)
	}
	chunkImageSize := imageSize / divisions
	return &amp;Picture{
		TopLeft:               topLeft,
		MaxIterations:         maxIterations,
		ChunkSize:             chunkSize / float64(divisions),
		HorizontalImageChunks: divisions,
		VerticalImageChunks:   divisions,
		ChunkImageSize:        chunkImageSize,
	}
}
</code></pre>

<p>After calling <code>pic.Init()</code>, we can call <code>pic.CalculateAsync()</code> to get the <code>doneIndex</code> channel that will notify us about the progress. As we need a little bit of setup with a context and a picture. I will wrap the calculation in a function <code>Calculate</code> that accepts the <code>pic</code> and returns an <code>image.RGBA</code> ready to be exported.</p>

<pre><code class="language-go">func Calculate(timeout int64, workers int, pic *mandelbrot.Picture) (*image.RGBA, error) {
	ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*time.Duration(timeout))
	defer ctxCancel()

	doneIndex := pic.CalculateAsync(ctx, workers)
	img := image.NewRGBA(image.Rect(0, 0, pic.HorizontalResolution(), pic.VerticalResolution()))

	for {
		select {
		case &lt;-ctx.Done():
			return img, ctx.Err()
		case i, ok := &lt;-doneIndex:
			if !ok {
				log.Print(&quot;Finished&quot;)
				return img, nil
			}
			log.Printf(&quot;Index %d done&quot;, i)
			offsetX, offsetY := pic.GetImageOffsetFor(i)
			paintAreaInImage(img, pic.GetArea(i), offsetX, offsetY)
		}
	}
}
</code></pre>

<p>The <code>mandelbot.Picture</code> provides utility method that return information about the final image dimensions. This way, I can prepare the final image. In the for loop we wait for updates from the calculation and call a function to paint the finished Area into the final image. The method <code>picture.GetImageOffserFor</code> accepts an index and returns the <code>x,y</code> positions in the resolution of the final image. If the context is cancelled. the <code>Calculate</code> function returns a partial image and the error that canceled the context. This way, if the context is cancelled. The function returns almost immediately. This could be a serious bug because workers will never be able to finish their work. But it is not a problem here because the program will just save the image and exit. I will solve this in future posts.</p>

<p>Let&rsquo;s take a look into the <code>paintAreaInImage</code> function. It&rsquo;s purpose is to iterate over all the pixels in the area, assign them a color, and add it to the final Image. The function <code>getColor</code> accepts <code>(point mandelbrot.Point, palette []color.RGBA, maxIterations int, maxIterationsColor color.RGBA)</code>  The color is chosen by dividing the iterations over the len of the palette. This ensures that we the next color for every iterations and that we loop back to the first one when the length is reached. The maxIterations is needed to paint the &ldquo;Unknown&rdquo; area of a different color. In this case, Black color.</p>

<pre><code class="language-go">func paintAreaInImage(img *image.RGBA, area mandelbrot.Area, offsetX int, offsetY int) {
	for x := 0; x &lt; area.HorizontalResolution; x++ {
		for y := 0; y &lt; area.VerticalResolution; y++ {
			point := area.GetPoint(x, y)
			color := getColor(point, []color.RGBA{
				color.RGBA{
					R: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					A: 255,
				},
				color.RGBA{
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					B: 255,
					A: 255,
				},
			}, area.MaxIterations, color.RGBA{
				A: 255,
			})
			img.SetRGBA(offsetX+x, offsetY+y, color)
		}
	}
}

func getColor(point mandelbrot.Point, palette []color.RGBA, maxIterations int, maxIterationsColor color.RGBA) color.RGBA {
	if point.Iterations() == maxIterations {
		return maxIterationsColor
	}
	index := point.Iterations() % len(palette)
	return palette[index]
}
</code></pre>

<p>When the function <code>Calculate</code> returns, we have a img object that must be saved to a file. If you pay attention to the parameters accepted by the program, it says that accepts png and jpeg formats. To do so, we can use the function <code>filepath.Ext</code> to find the extension of the file name. As go already provides codecs for jpeg and png. The code is straight forward.</p>

<pre><code class="language-go">outFile, err := os.Create(*out)
if err != nil {
	log.Fatalf(&quot;output file cannot be opened, cause: %s&quot;, err)
}
defer outFile.Close()

switch filepath.Ext(*out) {
case &quot;.jpg&quot;, &quot;.jpeg&quot;:
	encodingError := jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})
	if encodingError != nil {
		panic(err)
	}
case &quot;.png&quot;:
	encodingError := png.Encode(outFile, img)
	if encodingError != nil {
		panic(err)
	}
}
</code></pre>

<div class="expand">
    <div class="expand-label" id="expand-label-4" style="cursor: pointer;">
        <span>
            
            
            Click here to see all code
            
        </span>
    </div>
    <div class="expand-content" id="expand-content-4" style="display: none;">
        <pre><code class="language-go">package main

import (
	&quot;context&quot;
	&quot;flag&quot;
	&quot;image&quot;
	&quot;image/color&quot;
	&quot;image/jpeg&quot;
	&quot;image/png&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;runtime&quot;
	&quot;time&quot;

	&quot;github.com/metalblueberry/mandelbrot/mandelbrot&quot;
)

func main() {
	top := flag.Float64(&quot;top&quot;, 1.5, &quot;Top mandelbrot position&quot;)
	left := flag.Float64(&quot;left&quot;, -2.1, &quot;Left mandelbrot position&quot;)
	areaSize := flag.Float64(&quot;areaSize&quot;, 3, &quot;From the TopLeft, the size of the complex area&quot;)

	imageSize := flag.Int(&quot;imageSize&quot;, 1920, &quot;Size of the squared image generated in pixels&quot;)
	divisions := flag.Int(&quot;divisions&quot;, 50, &quot;Number of divisions to split the work over multiple routines&quot;)
	maxIterations := flag.Int(&quot;maxIterations&quot;, 100, &quot;Maximum number of iterations per point&quot;)

	workers := flag.Int(&quot;workers&quot;, runtime.NumCPU(), &quot;Maximum number of iterations per point&quot;)
	out := flag.String(&quot;out&quot;, &quot;mandelbrot.jpg&quot;, &quot;output file, it can be png or jpg&quot;)
	timeout := flag.Int64(&quot;timeout&quot;, 20, &quot;Maximum number of seconds to compute, if reached. the program will exit&quot;)

	flag.Parse()

	log.Printf(&quot;Start&quot;)

	pic := mandelbrot.NewPicture(complex(*left, *top), *areaSize, *imageSize, *divisions, *maxIterations)
	pic.Init()

	log.Printf(&quot;Calculation started&quot;)

	img, err := Calculate(*timeout, *workers, pic)
	if err != nil {
		log.Printf(&quot;Calculation failed, image is not complete. cause: %s&quot;, err)
	}

	outFile, err := os.Create(*out)
	if err != nil {
		log.Fatalf(&quot;output file cannot be opened, cause: %s&quot;, err)
	}
	defer outFile.Close()

	switch filepath.Ext(*out) {
	case &quot;.jpg&quot;, &quot;.jpeg&quot;:
		encodingError := jpeg.Encode(outFile, img, &amp;jpeg.Options{Quality: 90})
		if encodingError != nil {
			panic(err)
		}
	case &quot;.png&quot;:
		encodingError := png.Encode(outFile, img)
		if encodingError != nil {
			panic(err)
		}
	}
}

func Calculate(timeout int64, workers int, pic *mandelbrot.Picture) (*image.RGBA, error) {
	ctx, ctxCancel := context.WithTimeout(context.Background(), time.Second*time.Duration(timeout))
	defer ctxCancel()
	doneIndex := pic.CalculateAsync(ctx, workers)
	img := image.NewRGBA(image.Rect(0, 0, pic.HorizontalResolution(), pic.VerticalResolution()))

	for {
		select {
		case &lt;-ctx.Done():
			return img, ctx.Err()
		case i, ok := &lt;-doneIndex:
			if !ok {
				log.Print(&quot;Finished&quot;)
				return img, nil
			}
			log.Printf(&quot;Index %d done&quot;, i)
			offsetX, offsetY := pic.GetImageOffsetFor(i)
			paintAreaInImage(img, pic.GetArea(i), offsetX, offsetY)
		}
	}
}

func paintAreaInImage(img *image.RGBA, area mandelbrot.Area, offsetX int, offsetY int) {
	for x := 0; x &lt; area.HorizontalResolution; x++ {
		for y := 0; y &lt; area.VerticalResolution; y++ {
			point := area.GetPoint(x, y)
			color := getColor(point, []color.RGBA{
				color.RGBA{
					R: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					A: 255,
				},
				color.RGBA{
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					A: 255,
				},
				color.RGBA{
					G: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					B: 255,
					A: 255,
				},
				color.RGBA{
					R: 255,
					G: 255,
					B: 255,
					A: 255,
				},
			}, area.MaxIterations, color.RGBA{
				A: 255,
			})
			img.SetRGBA(offsetX+x, offsetY+y, color)
		}
	}
}

func getColor(point mandelbrot.Point, palette []color.RGBA, maxIterations int, maxIterationsColor color.RGBA) color.RGBA {
	if point.Iterations() == maxIterations {
		return maxIterationsColor
	}
	index := point.Iterations() % len(palette)
	return palette[index]
}
</code></pre>
    </div>
    <script>
        function collapse(e) {
            e = e || window.event;
            var target = e.target || e.srcElement,
                text = target.textContent || target.innerText;

            console.log("event received")
            console.log(target)

            target.classList.toggle("active");
            var content = this.nextElementSibling;
            console.log(content)
            console.log(content.style.display)
            if (content.style.display === "block") {
                content.style.display = "none";
                console.log(content.style.display)
            } else {
                content.style.display = "block";
            }
        }
        document.getElementById("expand-label-4").addEventListener("click", collapse);
    </script>
</div>

<h2 id="conclusion">Conclusion</h2>

<p>This has been really interesting. I was not expecting a x6 speed but looks like I was wrong. I think that the optimal number of divisions comes from a tread-off between the capacity to split the work over multiple cores and the extra time required to send data over channels. I would like to benchmark the code again and see where is the bottle neck for each configuration.</p>

<p>I think that the next project will be to create a mandelbrot-server that provides a webpage when the user will be able to zoom in the set dynamically. It would be awesome!</p>

<p>Checkout the whole code in the repository. Here is the <a href="https://github.com/MetalBlueberry/go-mandelbrot/releases/tag/2019-11-17_mandelbrot_parallel_computation">link</a> to the tag that hold the code at this moment. You can also <a href="https://github.com/MetalBlueberry/go-mandelbrot/releases/download/2019-11-17_mandelbrot_parallel_computation/mandelbrot">download the binary</a> for linux! just in case you want to run it without installing go.</p>

<p>Thank you for reading and feel free to leave a comment bellow, I will be really happy to hear from you.</p>

<h2 id="references">References</h2>

<ul>
<li><a href="https://golang.org/pkg/context/">Go context.Context</a></li>
<li><a href="https://golang.org/pkg/sync/#example_WaitGroup">Go sync.WaitGroup</a></li>
<li><a href="https://golang.org/pkg/image/">Go image</a></li>
<li><a href="https://tour.golang.org/concurrency/2">TourOfGo Channels</a></li>
<li><a href="https://medium.com/rungo/anatomy-of-channels-in-go-concurrency-in-go-1ec336086adb">Medium Anatomy of channels</a></li>
</ul></article><section class="article labels"><a class="category" href=/categories/howto/>howto</a><a class="tag" href=/tags/go/>go</a><a class="tag" href=/tags/mandelbrot/>mandelbrot</a></section></div><section class="article navigation"><p><a class="link" href="/post/blog/2019-11-24_avoid_github_government_block/"><span class="li">&larr;</span>Avoid Github Government Block</a></p><p><a class="link" href="/post/blog/2019-11-03_leadership_training/"><span class="li">&rarr;</span>Leadership Training</a></p></section><script src="https://utteranc.es/client.js" repo="MetalBlueberry/MetalBlueberry.github.io" issue-term="og:title"
    label="comment" theme="github-light" crossorigin="anonymous" async>
    </script></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Víctor Pérez Domingo</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150427130-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</body>

</html>