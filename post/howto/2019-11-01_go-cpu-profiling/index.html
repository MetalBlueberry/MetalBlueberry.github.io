<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.59.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Go CPU profiling&nbsp;&ndash;&nbsp;MetalBlueberry</title><link rel="stylesheet" href="/css/core.min.97dca4f10b4a76a5c62d6c5855e9eaab3b083ba20b6e4059f24dc20a8bb331c418ecdfd5449a29ef5333ebc2c64b286b.css" integrity="sha384-l9yk8QtKdqXGLWxYVenqqzsIO6ILbkBZ8k3CCouzMcQY7N/VRJop71Mz68LGSyhr"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go CPU profiling"/>
<meta name="twitter:description" content="Let&rsquo;s take a look to Go CPU profiling tools to optimize the mandelbrot set calculation from previous post."/>

<meta property="og:title" content="Go CPU profiling" />
<meta property="og:description" content="Let&rsquo;s take a look to Go CPU profiling tools to optimize the mandelbrot set calculation from previous post." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://metalblueberry.github.io/post/howto/2019-11-01_go-cpu-profiling/" />
<meta property="article:published_time" content="2019-11-01T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-04-10T11:39:35+02:00" />

<meta name="author" content="MetalBlueberry">
<body>
    <div class="base-body"><section id="header" class="site header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/android-chrome-512x512.png" alt /><span class="site name">MetalBlueberry</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/about">About</a><a class="nav item" href="/social">Follow me</a></nav></div></span></div><div class="site slogan"><span class="title">A passionate programmer</span></div></section><div id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Go CPU profiling</h1><p class="article date">Friday, November 1, 2019<span class="lastmod"> • edited Friday, April 10, 2020</span></p></section><article class="article markdown-body"><p>Let&rsquo;s take a look to Go CPU profiling tools to optimize the mandelbrot set calculation from previous post.</p>

<div class="admonition warning"><p class="admonition-title">warning</p>
  
<p>You should read <a href="/post/howto/2019-10-31_mandelbrot-set-calculation/">the previous post</a> to understand the context of this post.</p>


</div>

<p>After comparing the performance of the <a href="/post/howto/2019-10-31_mandelbrot-set-calculation/">Mandelbrot Set Calculation</a> with the interactive viewer online, I&rsquo;ve realized that the performance is really poor. For that reason, I&rsquo;m creating this post to show how to use CPU profiling tools to detect the bottleneck of the code and fix it.</p>

<h2 id="write-some-benchmarks">Write some benchmarks</h2>

<h3 id="the-good-feeling">The good feeling</h3>

<p>At first sight I see that the method <code>Diverges</code> can be easily optimized by avoiding the square root. So let&rsquo;s write some benchmarks to test that I&rsquo;m right.</p>

<p>The value external variable is to avoid optimizations during compile time that may reduce the benchmark time. <a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">Dave Cheney</a> explain all the details in his blog.</p>

<pre><code class="language-go">var value bool

func BenchmarkDiverges(b *testing.B) {
  for i := 0; i &lt; b.N; i++ {
    point := NewPoint(-0.5, 0.5)
    value = point.Diverges()
  }
}

func (m *Point) Diverges() bool {
  return cmplx.Abs(m.z) &gt; complex(2, 0)
}
</code></pre>

<p>I&rsquo;ve left the <code>Diverges</code> function here just as a reminder. let&rsquo;s run the benchmarks to see the output.</p>

<pre><code class="language-sh">╰─&gt;$ go test  -run='^$' -bench=BenchmarkDiverges
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkDiverges-6     168255253                6.43 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 1.464s
</code></pre>

<p>So we have 6.43 ns/op which is quite good. Let&rsquo;s modify the Diverges function and run it again.</p>

<pre><code class="language-go">func (m *Point) Diverges() bool {
  return real(m.z)*real(m.z)+imag(m.z)*imag(m.z) &gt; 4
}
</code></pre>

<pre><code class="language-sh">╰─&gt;$ go test  -run='^$' -bench=BenchmarkDiverges
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkDiverges-6     227208410                5.10 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 1.625s
</code></pre>

<p>There is a drop from 6.43 ns/op to 5.10 ns/op and <strong>this is a 20% faster!</strong> we are on the good track.</p>

<p>The bad news are that this is not the best way of optimizing the code. First we need to analyze it to see if saving 1 ns/op in this function is relevant or not to the whole computational work.</p>

<h3 id="full-benchmark">Full benchmark</h3>

<div class="admonition bug"><p class="admonition-title">Bug</p>
  
<p>There is a bug in the following benchmark function. Only the first iteration performs the real calculation. After that, the result is cached in the &ldquo;set&rdquo; variable. In the following post related to <a href="/tags/mandelbrot">mandelbrot</a> I fix this issue.</p>

<p>This means that the numbers in this benchmarks are not right if the number of executions is greater than 1. The good news are that the flame graph will be still reliable.</p>


</div>

<p>Let&rsquo;s write a benchmark function that simulates the whole process. The idea is to be as similar as possible to the main.</p>

<pre><code class="language-go">package mandelbrot_test

import (
  &quot;testing&quot;

  &quot;github.com/metalblueberry/mandelbrot/mandelbrot&quot;
)

func BenchmarkArea(b *testing.B) {
  set := mandelbrot.Area{
    HorizontalResolution: 200,
    VerticalResolution:   200,
    MaxIterations:        200,
    TopLeft:              complex(-2, 2),
    BottomRight:          complex(2, -2),
  }
  set.Init()
  // Start benchmarking here
  b.ResetTimer()
  for i := 0; i &lt; b.N; i++ {
    p := set.Calculate()
    // loop until p is closed
    for range p {
    }
  }
}
</code></pre>

<p>First let&rsquo;s compare the output with old Diverge function vs the output with the new one.</p>

<pre><code class="language-sh">## Initial
╰─&gt;$ go test  -run='^$' -bench=BenchmarkArea
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6             2016            564276 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 2.176s

## Optimized
╰─&gt;$ go test  -run='^$' -bench=BenchmarkArea
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6             3144            351339 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 1.950s

</code></pre>

<p>The code is 40% faster for this given section of the mandelbrot set, and we&rsquo;ve just removed a square root calculation.</p>

<h2 id="cpu-profiling">CPU profiling</h2>

<p>I&rsquo;m going to run the full benchmark again but this time with the flag <code>-cpuprofile</code> and this will generate a profiling file.</p>

<pre><code class="language-sh">╰─&gt;$ go test -run='^$' -bench=BenchmarkArea  -cpuprofile profile.out
</code></pre>

<p>To visualize the profile.out file, we need the go tool pprof. It is a really powerful tool, but for now, let&rsquo;s keep it simple and just run the web interface with the following command.</p>

<pre><code class="language-sh">go tool pprof -http localhost:8080 profile.out
</code></pre>

<p>The web page will open in the graph view. But personally I prefer to visualize this as a flame graph. You can do this by clicking in <a href="http://localhost:8080/ui/flamegraph">view&gt;flame graph</a>.</p>

<p><img src="flamegraph-master.png" alt="flamegraph-master" /></p>

<p>And here is the problem. <strong>cmplx.Abs function is taking 31.74% of the time</strong>. Let&rsquo;s run the benchmark again but with the optimization.</p>

<p><img src="flamegraph-improved.png" alt="flamegraph-improved" /></p>

<p>Wonderful. The Diverges function now only takes 8.45% of the time. what is the next top offender to the computation time? To answer this question we can keep looking at the flame graph or go directly to the <code>top</code> view where we can see the time spent in each function.</p>

<table>
<thead>
<tr>
<th>flat</th>
<th>flat%</th>
<th>sum%</th>
<th>cum</th>
<th>cum%</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>680ms</td>
<td>31.92%</td>
<td>31.92%</td>
<td>2060ms</td>
<td>96.71%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Area).Calculate.func1</td>
</tr>

<tr>
<td>330ms</td>
<td>15.49%</td>
<td>47.42%</td>
<td>350ms</td>
<td>16.43%</td>
<td>runtime.chansend</td>
</tr>

<tr>
<td>260ms</td>
<td>12.21%</td>
<td>59.62%</td>
<td>820ms</td>
<td>38.50%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Point).Calculate</td>
</tr>

<tr>
<td>210ms</td>
<td>9.86%</td>
<td>69.48%</td>
<td>560ms</td>
<td>26.29%</td>
<td>runtime.selectnbsend</td>
</tr>

<tr>
<td>180ms</td>
<td>8.45%</td>
<td>77.93%</td>
<td>180ms</td>
<td>8.45%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Point).Diverges</td>
</tr>

<tr>
<td>90ms</td>
<td>4.23%</td>
<td>82.16%</td>
<td>90ms</td>
<td>4.23%</td>
<td>math.Sincos</td>
</tr>

<tr>
<td>70ms</td>
<td>3.29%</td>
<td>85.45%</td>
<td>70ms</td>
<td>3.29%</td>
<td>math.xatan</td>
</tr>

<tr>
<td>40ms</td>
<td>1.88%</td>
<td>87.32%</td>
<td>40ms</td>
<td>1.88%</td>
<td>math.Hypot</td>
</tr>

<tr>
<td>40ms</td>
<td>1.88%</td>
<td>89.20%</td>
<td>40ms</td>
<td>1.88%</td>
<td>math.IsInf</td>
</tr>

<tr>
<td>40ms</td>
<td>1.88%</td>
<td>91.08%</td>
<td>380ms</td>
<td>17.84%</td>
<td>math/cmplx.Pow</td>
</tr>
</tbody>
</table>

<p>The first surprise here is that runtime.chansend and runtime.selectnbsend are taking 42% of the time and is something that just reports the progress! Let&rsquo;s remove it.</p>

<h2 id="optimizations">Optimizations</h2>

<h3 id="progress-reporting">Progress reporting</h3>

<p>It is important to notice that will make Calculate function synchronous.</p>

<pre><code class="language-go">// Previous
func (a *Area) Calculate() (progress chan int) {
  progress = make(chan int)
  go func() {
    defer close(progress)
    for i, pixel := range a.Points {
      pixel.Calculate(a.MaxIterations)
      a.Points[i] = pixel

      select {
      case progress &lt;- i:
      default:
      }
    }
  }()
  return
}

// New
func (a *Area) Calculate() {
  for i, pixel := range a.Points {
    pixel.Calculate(a.MaxIterations)
    a.Points[i] = pixel
  }
}
</code></pre>

<p>We need to remove the channel from the benchmark too</p>

<pre><code class="language-go">// Previous
func BenchmarkArea(b *testing.B) {
  set := mandelbrot.Area{
    HorizontalResolution: 200,
    VerticalResolution:   200,
    MaxIterations:        200,
    TopLeft:              complex(-2, 2),
    BottomRight:          complex(2, -2),
  }
  set.Init()
  b.ResetTimer()
  for i := 0; i &lt; b.N; i++ {
    progress := set.Calculate()
    for range progress {
    }
  }
}
  

// New
func BenchmarkArea(b *testing.B) {
  set := mandelbrot.Area{
    HorizontalResolution: 200,
    VerticalResolution:   200,
    MaxIterations:        200,
    TopLeft:              complex(-2, 2),
    BottomRight:          complex(2, -2),
  }
  set.Init()
  b.ResetTimer()
  for i := 0; i &lt; b.N; i++ {
    set.Calculate()
  }
}
</code></pre>

<p>And the benchmark now is&hellip;</p>

<pre><code class="language-sh">╰─&gt;$ go test -run='^$' -bench=BenchmarkArea  -cpuprofile profile.out
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6             5301            206832 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 2.007s
</code></pre>

<p>If you scroll up to check the previous result, we&rsquo;ve improved from 351339 ns/op to 206832 ns/op. Let&rsquo;s get the flame graph and the top to see how to continue.</p>

<table>
<thead>
<tr>
<th>flat</th>
<th>flat%</th>
<th>sum%</th>
<th>cum</th>
<th>cum%</th>
<th></th>
</tr>
</thead>

<tbody>
<tr>
<td>0.93s</td>
<td>49.21%</td>
<td>49.21%</td>
<td>1.89s</td>
<td>100%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Area).Calculate</td>
</tr>

<tr>
<td>0.45s</td>
<td>23.81%</td>
<td>73.02%</td>
<td>0.96s</td>
<td>50.79%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Point).Calculate</td>
</tr>

<tr>
<td>0.17s</td>
<td>8.99%</td>
<td>82.01%</td>
<td>0.17s</td>
<td>8.99%</td>
<td>github.com/metalblueberry/mandelbrot/mandelbrot.(*Point).Diverges</td>
</tr>

<tr>
<td>0.11s</td>
<td>5.82%</td>
<td>87.83%</td>
<td>0.12s</td>
<td>6.35%</td>
<td>math.Sincos</td>
</tr>

<tr>
<td>0.06s</td>
<td>3.17%</td>
<td>91.01%</td>
<td>0.06s</td>
<td>3.17%</td>
<td>math.Hypot</td>
</tr>

<tr>
<td>0.05s</td>
<td>2.65%</td>
<td>93.65%</td>
<td>0.10s</td>
<td>5.29%</td>
<td>math.pow</td>
</tr>

<tr>
<td>0.02s</td>
<td>1.06%</td>
<td>94.71%</td>
<td>0.02s</td>
<td>1.06%</td>
<td>math.Abs</td>
</tr>

<tr>
<td>0.02s</td>
<td>1.06%</td>
<td>95.77%</td>
<td>0.02s</td>
<td>1.06%</td>
<td>math.IsInf</td>
</tr>

<tr>
<td>0.02s</td>
<td>1.06%</td>
<td>96.83%</td>
<td>0.05s</td>
<td>2.65%</td>
<td>math.atan2</td>
</tr>

<tr>
<td>0.01s</td>
<td>0.53%</td>
<td>97.35%</td>
<td>0.01s</td>
<td>0.53%</td>
<td>math.frexp</td>
</tr>
</tbody>
</table>

<p><img src="flamegraph-progress.png" alt="flamegraph-progress" /></p>

<p>96% of the time is spent inside the Area.Calculate function and this means that we are not wasting time doing other stuff. Appart from that, I would expect to spend most of the time inside Point.Calculate, as it is where the iterations are performed. Let&rsquo;s go to the <a href="http://localhost:8080/ui/source">source tab</a> to see the time spent per line.</p>

<pre><code class="language-go">  Total:       930ms      1.89s (flat, cum)   100%
     33            .          .           func (a *Area) Calculate() {
     34        510ms      510ms             for i, pixel := range a.Points {
     35        140ms      1.10s               pixel.Calculate(a.MaxIterations)
     36        280ms      280ms               a.Points[i] = pixel
     37            .          .             }
     38            .          .           }
</code></pre>

<p>So we spend <sup>1</sup>&frasl;<sub>3</sub> of the time iterating over the Points array and assigning back the value. I feel a little bit lost at this point so let&rsquo;s just modify the code to see if it can be improved. The first thing I want to try is to replace the range operation for a simple for loop.</p>

<h3 id="slice-traversal">Slice traversal</h3>

<p>This is the new version of the Calculate function.</p>

<pre><code class="language-go">// Previous
func (a *Area) Calculate() {
  for i, pixel := range a.Points {
    pixel.Calculate(a.MaxIterations)
    a.Points[i] = pixel
  }
}
// New
func (a *Area) Calculate() {
  for i := 0; i &lt; len(a.Points); i++ {
    a.Points[i].Calculate(a.MaxIterations)
  }
}
</code></pre>

<pre><code class="language-sh">╰─&gt;$ go test -run='^$' -bench=BenchmarkArea  -cpuprofile profile.out
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6            10767            105798 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 1.906s
</code></pre>

<p><img src="flamegraph-slice-traversal.png" alt="flamegraph-slice-traversal" /></p>

<pre><code class="language-go">  Total:       390ms      1.71s (flat, cum)   100%
    33            .          .           func (a *Area) Calculate() {
     34        210ms      210ms             for i := 0; i &lt; len(a.Points); i++ {
     35        180ms      1.50s               a.Points[i].Calculate(a.MaxIterations)
     36            .          .             }
     37            .          .           }
</code></pre>

<p>This change gives us 105798 ns/op which is near two times faster than the previous version! This is great. If you check the initial benchmark, it was 564276 ns/op so this means we are already x5 times faster.</p>

<p>Before continuing the optimization, I&rsquo;ve decided to compare the performance vs the <a href="https://sciencedemos.org.uk/mandelbrot.php">online viewer</a>. Just to have some reference of how fast can this task be performed. The sad news are that for the following section, our implementation takes 100s and the online viewer takes 3.7s.</p>

<p>The BenchmarkComplexArea function is the one that takes 100s.</p>

<pre><code class="language-go">
func BenchmarkArea(b *testing.B) {
  set := mandelbrot.Area{
    HorizontalResolution: 200,
    VerticalResolution:   200,
    MaxIterations:        200,
    TopLeft:              complex(-2, 2),
    BottomRight:          complex(2, -2),
  }
  benchmarkGivenArea(b, set)
}

func BenchmarkComplexArea(b *testing.B) {
  set := mandelbrot.Area{
    HorizontalResolution: 1060,
    VerticalResolution:   730,
    MaxIterations:        3534,
    TopLeft:              complex(-1.401854499759, -0.000743603637),
    BottomRight:          complex(-1.399689899172, 0.000743603637),
  }
  benchmarkGivenArea(b, set)
}

func benchmarkGivenArea(b *testing.B, set mandelbrot.Area) {
  set.Init()
  b.ResetTimer()
  for i := 0; i &lt; b.N; i++ {
    set.Calculate()
  }
}
</code></pre>

<p>When running this benchmark, I&rsquo;ve got an interesting profile.out that shows that 93.13% of the time is spent in math/cmplx.Pow function.</p>

<p><img src="flamegraph-benchmarkComplexArea.png" alt="flamegraph-benchmarkComplexArea" /></p>

<p>This is really sad because this function is really useful and I don&rsquo;t see a clear way of optimizing it. I guess that as this function can handle any power number. An optimization can be just multiplying the number by itself. Let&rsquo;s try.</p>

<h3 id="math-pow">math.Pow</h3>

<p>Another easy change. These are the old and the new version of <code>point.Calculate</code></p>

<pre><code class="language-go">// Previous
func (m *Point) Calculate(MaxIterations int) {
  for !m.Diverges() &amp;&amp; m.iterations &lt; MaxIterations {
    m.iterations++
    m.z = cmplx.Pow(m.z, 2) + m.Point
  }
}
// New
func (m *Point) Calculate(MaxIterations int) {
  for !m.Diverges() &amp;&amp; m.iterations &lt; MaxIterations {
    m.iterations++
    m.z = m.z*m.z + m.Point
  }
}
</code></pre>

<p>Let&rsquo;s run benchmarks&hellip;</p>

<pre><code class="language-sh">## Previous
╰─&gt;$ go test -run='^$' -bench=Area  -cpuprofile profile.out                                                        12:31:28
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6                    12500             96135 ns/op
BenchmarkComplexArea-6                 1        103429981309 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 106.306s

## New
╰─&gt;$ go test -run='^$' -bench=Area  -cpuprofile profile.out
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6                    15406             73572 ns/op
BenchmarkComplexArea-6                 1        5013357483 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 5.511s
</code></pre>

<p>I think we&rsquo;ve found the top offender to the calculation and easily improved it. now the timing is 5013357483 ns/op for the ComplexArea which is 5.013357483 s/op and this is only 1.3 seconds away from the web page!</p>

<div class="admonition tip"><p class="admonition-title">learning</p>
  
<p>Don&rsquo;t use math.Pow unless you really need it.</p>


</div>

<div class="admonition bug"><p class="admonition-title">bug</p>
  
<p>After this change, the tests are failing because the case <code>(0,1)</code> no longer diverges. We&rsquo;ve solved this numerical issue when removing <code>math.Pow</code> and the tests must be updated.</p>


</div>

<h3 id="pointer-dereference">Pointer dereference</h3>

<p>Inside the method point.Calculate there are several references to variables inside Point. This forces the program to dereference the variables each loop and this is a waste of time. To fix it I&rsquo;m going to create a copy of the variables at the beginning of the method. It is also required to inline the <code>Diverges</code> method.</p>

<pre><code class="language-go">// Previous
func (m *Point) Calculate(MaxIterations int) {
  for !m.Diverges() &amp;&amp; m.iterations &lt; MaxIterations {
    m.iterations++
    m.z = m.z*m.z + m.Point
  }
}

func (m *Point) Diverges() bool {
  return real(m.z)*real(m.z)+imag(m.z)*imag(m.z) &gt; 4
}

// New
func (m *Point) Calculate(MaxIterations int) {
  var z complex128
  point := m.Point
  iterations := m.iterations

  for real(z)*real(z)+imag(z)*imag(z) &lt; 4 &amp;&amp; iterations &lt; MaxIterations {
    iterations++
    z = z*z + point
  }

  m.iterations = iterations
}
</code></pre>

<p>And running benchmarks again&hellip;</p>

<pre><code class="language-sh">## Previous
╰─&gt;$ go test -run='^$' -bench=.
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6                    16176             76731 ns/op
BenchmarkComplexArea-6                 1        5011883400 ns/op
BenchmarkCalculate-6               94263             12727 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 8.308s

## New
╰─&gt;$ go test -run='^$' -bench=.
goos: linux
goarch: amd64
pkg: github.com/metalblueberry/mandelbrot/mandelbrot
BenchmarkArea-6                    13608             81561 ns/op
BenchmarkComplexArea-6                 1        3520533936 ns/op
BenchmarkCalculate-6              130862              8912 ns/op
PASS
ok      github.com/metalblueberry/mandelbrot/mandelbrot 6.284s
</code></pre>

<p>It is interesting that the benchmark for the first area is slightly slower even though the other two are faster. I can&rsquo;t give a explanation why this happen. Anyway, the time for the complex are is&hellip; 3.5 seconds!! faster than the webpage.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I&rsquo;m really happy with the result of the optimization. We have improved the code to run 85% faster than the initial version and this is quite impressive. I think the next step is to render the set by chunks to parallelize the computational task and take advantage of the multiple cores.</p>

<p>You can explore the repository to see the whole code and to play with it.</p>

<p>Thank you for reading and feel free to leave a comment bellow, I will be really happy to hear from you.</p>

<h2 id="references">References</h2>

<ul>
<li><a href="https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go">How to write go benchmark by Dave Cheney</a></li>
<li><a href="https://www.speedscope.app/">Online flamegraph visualizer</a></li>
<li><a href="https://sciencedemos.org.uk/mandelbrot.php">Online mandelbrot visualizer</a></li>
<li><a href="https://github.com/bradfitz/talk-yapc-asia-2015/blob/master/talk.md">Profiling &amp; Optimizing in Go</a></li>
</ul></article><section class="article labels"><a class="category" href=/categories/howto/>howto</a><a class="tag" href=/tags/go/>go</a><a class="tag" href=/tags/mandelbrot/>mandelbrot</a></section></div><section class="article navigation"><p><a class="link" href="/post/blog/2019-11-03_leadership_training/"><span class="li">&larr;</span>Leadership Training</a></p><p><a class="link" href="/post/howto/2019-10-31_mandelbrot-set-calculation/"><span class="li">&rarr;</span>Mandelbrot Set Calculation</a></p></section><script src="https://utteranc.es/client.js" repo="MetalBlueberry/MetalBlueberry.github.io" issue-term="og:title"
    label="comment" theme="github-light" crossorigin="anonymous" async>
    </script></div><section id="footer" class="footer"><div class="footer-wrap">
    <p class="copyright">Víctor Pérez Domingo</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-150427130-1', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</div>
</body>

</html>